---
title: 안드로이드 애플리케이션 설계
author: Yun-Jae Na
date: 2020-06-29 16:38:00 +0900
categories: [Android, Advance]
tags: [Android]
---

# 안드로이드 애플리케이션 소개

## 1\. 애플리케이션 설계란?

애플리케이션 설계는 구성 요소들 사이에서 유기적 관계를 표현하고, 요구 사항을 해결하려는 계획 과정 등의 원칙을 나타냄 설계에 대한 설명은 주로 텍스트나 그림, 다이어그램을 비록한 다양한 형식을 취함

애플리케이션은 우선 구현되고 나면 변경하는데 비용이 많이 듬. 시간이 지남에 따라 안드로이드의 정책이 바뀌고, 시장의 요구 상이 변경되어 애플리케이션에 대한 지속적인 유지 보수가 필요하게 됨. 이때 애플리케이션도 점점 거대해져 유지보수비는 점점 커질 수 밖에 없음. 잘 설계된 애플리케이션은 유지 보수비를 줄여 주고, 성능, 보안, 안정성 등의 측면에서 많은 이점이 있다.

애플리케이션 설계에는 끊임없는 노력이 필요하다. 변화에 대응하지 않고, 시간이 흐르면 아무리 잘 설계된 앱도 무너질 수밖에 없다. 예를 들어, 안드로이드 앱을 잘 만들어서 배포를 마친 상태인데, 이에 대해 유지 보수를 하지 않으면 이후에 나오는 안드로이드 플랫폼 버전과 호환되지 않거나 마켓 정책상의이유로 앱이 제 기능을 하지 못한다. 따라서 애플리케이션 설께에서 가장 중요한 점은 개발자가 이러한 설계 및 유지 보수에 대해서 지속해서 고민하고 발전시키려는 의지다.

## 2\. 애플리케이션의 설계 원칙

좋은 애플리케이션 설계를 위해서는 어떠한 원칙을 정하고, 그것을 기반으로 프로그램을 작성한다면 적어도 원칙 없이 작성한 코드보다는 더 나은 결과물을 볼 수 있다. 2000년대 초반 로버트 C. 마틴이 객체 지향 프로그래밍 및 설계에 대한 SOLID라는 5가지 원칙을 소개하였다. SOLID원칙은 5가지 원칙에서 각 원칙의 머리글자를따와 만든 명칭이다. 유지 보수와 확장이 쉬운 애플리케이션을 만들려고 할 때 이 원칙을 적용할 수 있다. 코드의 가독성을 높이고 확장이 쉬운 구조를 만드는 지침이다.

### 단일 책임 원칙 (Single Responsibility Principle)

객체 지향 프로그래밍에서 단일 책임 원칙(Single Responsibility Principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책이과 주의 깊게 부합해야 한다.

단일 책임은 어떤 클래스나 모듈 또는 메서드가 단 하나의 기능을 가져야 한다는 뜻이다. 즉 변경 사항이 발생하더라도 그 변경 사항에 대한 책임이 있는 부분만 수정하면 된다. 예를 들어 특정 데이터를 분석하고 서버에 전송하는 모듈을 생각해 보면, 이 모듈은 두 가지 이유로 변경될 수 있다. 첫 번째로 데이터를 분석하는 알고리즘 때문에 변경될 수 있다. 두 번째로 서버에 전송하는 형식 때문에 변경될 수 있다. 단일 책임 원칙에 의하면 이 문제의 두 측면이 실제로 분리된 두 책임 때문이며, 따라서 분리된 클래스나 모듈로 나누어야 한다. 다른 시기에 다른 이유로 변경되어야 하는 두 가지를 묶는 것은 나쁜 설계일 수 있다.

한 클래스를 한 관심사에 집중하도록 유지하는 것이 중요한 이유는, 이것이 클래스를 더욱 튼튼하게 하기 때문이다. 앞서 든 예를 계속 살펴보면, 변경이 일어나면, 같은 클래스의 일부로 출력 코드가 망가질 위험이 대단히 높다.

### 개방 - 폐쇄 원칙 (Open Closed Principle)

개방-폐쇄 원칙 (OCP, Open-Closed Principle)은 소프트웨어가 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙이다.

어떠한 내용을 수정하기 위해 연관된 다른 코드나 모듈까지 수정하는 것은 어렵고 난감하다. 개방-폐쇄 원칙은 시스템의 구조를 올바르게 구성하여 변경 사항이 발생하더라도 다른 코드나 모듈에 영향이 없도록 하는 것이다. 개방 - 폐쇄 원칙이 잘 적용된 경우, 새로운 기능을 추가하거나 기존 기능을 변경하기가 용이해진다.

개방 - 폐쇄 원칙은 객체 지향 프로그래밍의 핵심 원칙이라고 할 수 있다. 개방-폐쇄 원칙을 따르지 않는다고 해서 객체 지향 언어 구현이 불가능한 것은 아니지만, 이 원칙을 무시하고 프로그래밍을 한다면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지 보수성 등을 결코 얻을 수 없다. 따라서 객체 지향 프로그래밍 언어에서 개방 - 폐쇄 원칙은 반드시 지켜야 할 기본적인 원칙이다.

### 리스코프 치환 원칙 (Liskov Substitution Principle)

치환성은 객체 지향 프로그래밍 원칙이다. 클래스 S가 클래스 T의 자식 클래스라면 별다른 변경 없이 부모 클래스 T를 자식 클래스 S로 치환할 수 있어야 한다는 원칙이다. 즉 다운 캐스팅된 인스턴스가 논리적으로 그 역할이 문제없어야 한다.

리스코프의 원칙은 객체 지향 프로그래밍 특징에 관한 몇 가지 표준적인 요구 사항을 강제한다.

-   하위 클래스에서 메서드 파라미터의 반공변성
-   하위 클래스에서 반환형의 공변성
-   하위 클래스에서 메서드는 상위 클래스 메서드에서 던져진 예외 사항을 제외하고 새로운 예외 사항을 던지면 안됨
-   하위 클래스에서 선행 조건은 강화될 수 없음
-   하위 클래스에서 후행 조건은 약화할 수 없음
-   하위형에서 상위형의 불변 조건은 반드시 유지되어야 함

다음과 같이 차례로 상속받는 타입이 있다고 가정한다.

A <- B <- C

```java
public class A {}
public class B extends A {}
public class C extends B {}
```

공변성의 예를 들면, List<? extends B> 란 B를 상속받는 타입으로 이루어진 리스트가 있다면 List를 사용할 수 있다는 내용이다. 반공변성의 예를 들면, List<? extends B> 란 리스트가 있을 때 List< A > 를 사용할 수 있다는 것이다. 물론 A의 부모 타입으로도 치환이 가능하다. 불변성은 위의 공변성과 반공변성을 허용하지 않는 경우이다.

### 인터페이스 분리 원칙 (Interface Segregation Principle)

인터페이스 분리 원칙은 어떠한 클래스가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리함으로써 클래스들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 이와 같은 작은 단위들을 역할 인터페이스라고도 부른다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화해 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

인터페이스 분리 원칙의 이해를 돕기 위해 독수리를 클래스로 표현하는 다음 예제를 살펴보면

```java
public abstract class Bird {
  abstract void fly();
  abstract void cry();
}
```

```java
public class Eagle extends Bird {
  @Override
  public void fly(){ ... }

  @Override
  public void cry(){ ... }
}
```

Bird라는 추상 클래스를 만들어서 새의 울음소리를 내고 날 수 있는 기능을 가진 메서드를 만든 뒤 Bird를 상속받은 Eagle을 만들었다. 이때 Penguin 클래스를 만든다면 펭귄은 새지만 날지는 못하므로 fly() 메서드를 가지면 ISP 인터페이스 분리 원칙에 어긋날 수 있다. 다음과 같이 코드를 수정할 수 있다.

```java
public abstract class Bird{
  abstract void cry();
}
```

```java
public interface Flyable{
  void fly();
}
```

```java
public abstract class FlyableBird extends Bird implements Flyable{ ... }
```

```java
public class Eagle extends FlyableBird{
  @Override
  public void fly() { ... }

  @Override
  public void cry() { ... }
}
```

```java
public class Penguin extends FlyableBird{
  @Override
  public void cry() { ... }
}
```

fly() 메서드를 인터페이스로 분리하고 날 수 있는 새에만 구현함으로써 펭귄은 사용하지 않는 fly() 메서드를 가지지 않을 수 있어 ISP 원칙을 지킬 수 있게 되었다. 펭귄에게 swim() 메서드를 추가하고 싶다면 Swimmable 인터페이스를 만들어 볼 수도 있다.

### 의존 역전 원칙 (Dependency Inversion Principle)

객체 지향 프로그래밍에서 의존 역전 원칙은 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.

첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.  
둘째, 추상화는 세부 사항에 의존해서는 안 왼다. 세부 사항이 추상화에 의존해야 한다.  
이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다.'는 객체 지향적 설계의 대원칙을 제공한다.

## 3\. 클린 아키텍처

클린 아키텍처는 로버트 C. 마틴에 의해 만들어진 철학으로, 소프트웨어의 관심사를 계층별로 분리하는 소프트웨어 디자인 철학이다. 클린 아키텍처의 주요 원칙은 코드 종속성이 외부로부터 내부로 의존한다는 것이다. 내부 계층의 코드는 외부 게층의 기능을 알 수 없다. 외부 계층에서 존재하는 변수, 함수 및 클래스(모든 엔티티)는 안쪽 계층에서 다시 등장할 수 없다. 데이터 형식도 계층 간에 별도로 유지하는 것이 좋다.

가운데 원은 가장 추상적인 영역이다. 비즈니스 로직을 포함하고 사용 중인 플랫폼이나 프레임워크에 의존해서는 안 된다. 외부 원은 네트워크 및 데이터베이스의 접근처럼 플랫폼ㅇ레 특정한 구체적인 구현 세부 사항이 포함된다.

클린 아키텍처를 사용했을 때의 장점은 계층을 분리하고 계층 간의 의존성을 단방향으로 만들기 때문에 코드의 재사용성이 용이해지고, 유닛 테스트가 쉬워진다는 것이다.

기본적인 의존성 규칙은 변함이 없다. 내부 계층은 외부 계층을 알면 안 된다. 이것만 잘 지키면 계층을 몇 개로 나누어도, 어떻게 나누어도 크게 상관없다. 만약 계층이 더 필요하다면 나누어서 관리하면 된다. 의존성 규칙만 잘 지키면 되며, 항상 바깥쪽에서 안쪽으로 참조하며, 안쪽 계층으로 진입할수록 추상화와 캡슐화 수준이 높아진다.

### Entities

엔티티는 전사적 비즈니스 규칙을 캡슐화한다. 데이터의 구조나 메서드를 포함하는 객체이다. 전사적으로 많은 다른 애플리케이션 사이에 사용될 수 있다.

하나의 애플리케이션을 위한 엔터티라면 애플리케이션의 비즈니스 로직을 담고, 가장 일반적이고 상위 수준의 규칙들을 캡슐화 한다. 외부에서 무언가 변경되었을 때 가장 최소한의 변경 사항을 가져야만 한다. 예를 들어 화면의 이동, 보안과 관련된 내용이 변경되었을 때도 엔터티 계층은 영향을 받으면 안 된다.

네트워크나 데이터베이스와 관련된 클래스를 작성할 때 POJO와 같은 데이터 클래스를 작성하는데, 그러한 클래스들이 이 계층에 속한다고 볼 수 있다. 이러한 데이터 클래스들은 안드로이드 애플리케이션과 관련된 코드를 포함해서는 안 된다. 순수한 자바 또는 코틀린 코드일 때 유닛 테스트가 수월하다.

### Use Cases

유스 케이스 계층에서는 애플리케이션과 관련된 비즈니스 규칙을 포함하고 시스템의 모든 유스 케이스 구현체들을 캡슐화한다. 이러한 유스 케이스들은 엔티티로부터의 데이터 흐름들을 관리하고, 유스 케이스의 목적을 달성하도록 엔티티에 넓고 전사적인 비즈니스 규칙의 사용을 가르친다. 관심사를 분리하여 계층을 분리해 이 계층은 엔티티에 영향을 미치지 않으며, UI 나 프레임워크 같은 외부 계층에서도 영향을 받지 않는다.

안드로이드에서는 Model, Repository, Executor등과 관련된 내용이 이 계층에 속할 수 있다.

-   Model : 데이터베이스의 질의나 네트워크 요청 등의 비즈니스 로직을 수행한다.
-   Repository : 내부 DB에 접근하거나 저장 또는 원격 서버의 데이터를 요청하는 역할을 한다. 일반적으로 인터페이스이며 인터페이스를 구현하여 외부 계층의 연결을 느슨하게 한다.
-   Executor : Repository나 Model과 관련된 작업이 백그라운드에서 작업을 수행할 수 있도록 작업 스레드를 관리하고 제공한다.

### Interface Adapters

이 계층은 유스 케이스나 엔터티로부터 얻은 데이터를 가공하는 계층이다. 비즈니스 로직을 수행하여 원하는 결과값을 얻어 UI에 표현하려고 적당한 형식으로 데이터를 변경하며, 아키텍처 디자인 패턴에서 흔히 말하는 Presenter, View, ViewModel, Controller 같은 관심사가 여기에 속한다. 반대로 UI로부터 얻은 데이터를 내부 DB나 원격 서버에 전송할 때도 이 계층에서 데이터를 가공하여 전달한다.

### Frameworks 와 Drivers

가장 바깥쪽 계층으로 일반적으로 안드로이드에서는 UI와 관련된 액티비티, 프래그먼트, 인텐트 전달 그리고 데이터에 접근하고 저장하는 데이터베이스, 콘텐츠 프로바이더가 포함되며, 마지막으로 Retrofit과 같은 네트워크와 관련된 프레임워크 코드가 이곳에 속한다. 일반적인 애플리케이션 개발자가 프레임워크 코드를 수정할 일은 많지 않다.

관심사가 분리된 코드를 사용하면 많은 소프트웨어가 방해받지 않고 특정 문제에 집중할 수 있다. 클린 아키덱처는 SOLID 원칙을 잘 따른 일종의 모범 패턴이다.

클린 아키텍처에는 정답은 없다. 상황에 따라 조금씩 다른 형태를 가질 수 있으나 원칙은 변하지 않는다. 원칙만 잘 따르면 많은 문제점을 해결하고 더 나은 산출물을 만들 수 있는 것은 분명하다.

## 4\. 안드로이드의 특징

하나의 진입점, 하나의 프로세스에서 실행되는 일반적인 애플리케이션과 달리 안드로이드 애플리케이션은 액티비티, 프래그먼트, 서비스, 브로드캐스트 리시버, 콘텐츠 프로바이더 등의 컴포넌트로 구성되며, 여러 프로세스로 실행될 수 있고, 진입점 또한 다양하다.

안드로이드는 짧은 시간 이내에 여러 애플리케이션과 상호 작용하는 경우가 많다. 예를 들어 SNS 애플리케이션에서 사진을 촬영하여 공유하려고 암시적 인텐트로 카메라 애플리케이션에서 사진을 촬영하여 공유하려고 암시적 인텐트로 카메라 애플리케이션을 호출하여 사진을 찍고, 결과물을 가지고 SNS 애플리케이션으로 돌아오는 경우가 있고, 또 다른 경우는 쇼핑몰 애플리케이션에서 결제를 진행하려고 카드사 애플리케이션을 실행하고 결제가 끝난 뒤 결과 정보를 가지고 쇼핑몰 애플리케이션으로 돌아오는 경우가 있다. 이러한 과정에서 언제든지 전화나 알림 또는 메모리 부족으로 인해 기존에 하던 작업이 방해를 받거나 중단될 수 있다. 사용자는 이러한 내용과 관계없이 하던 작업을 계속하기를 기대하는데, 개발자가 이러한 예외 사항에 대해 처리하지 않는다면 아마 사용자는 다시는 이 애플리케이션을 사용하지 않을지도 모른다.

앞의 예와 같이 안드로이드는 컴포넌트는 언제든지 실행되고 메모리 부족과 같은 시스템 조건으로 인해 의도치 않게 종료될 수 있다. 이러한 컴포넌트의 생명 주기는 개발자가 직접 제어하는 것이 아닌 안드로이드 시스템이 제어하기 때문에 데이터 및 상태에 대한 내용을 컴포넌트에 저장하는 것은 위험하다.

## 5\. 안드로이드 애플리케이션 설계 원칙

초보 개발자가 앱을 만들다 보면 액티비티 또는 프래그먼트 같은 UI 컴포넌트에 많은 코드를 작성하기 쉽다. Context, View, 데이터, 시스템 이벤트 등을 쉽게 참조할 수 있어 코드량이 쉽게 거대해진다. UI 컴포넌트에 데이터를 저장하게 된다면 앞에서 말한 예외 사항들에 대응하기도 힘들고, 거대해진 코드량 때문에 코드 가독성 또한 떨어진다. 그러므로 액티비티와 프래그먼트의 클래스 의존성은 최소화하는 것이 좋다.

따라서 가장 중요한 원칙은 관심사 분리다. 애플리케이션을 구별된 부분으로 분리하는 디자인 원칙으로 각 부분은 개개의 관심사를 해결한다. 관심사란 어떠한 상태나 데이터에 영향을 미치는 정보의 집합이다. SOLID 원칙과도 많은 부분이 부합되며, 결국 관심사 분리라는 것은 클래스 간의 강한 의존성을 느슨하게 하면서 모듈화시킨다. 모듈이란 것은 다른 모듈로부터 독립적이며 영역에 따라 다른 역할을 한다는 의미이다. 이렇게 관심사 분리를 통해 모듈화를 성공적으로 마치면 애플리케이션의 설계, 배포, 유닛 테스트와 같은 일부의 관점에서 더 높은 자유도가 생긴다. 코드 또한 단순화되고 유지 보수 측면에서 더 적은 비용이 들어간다. 관심사가 잘 분리될 때 독립적인 개발과 재사용성도 중대하므로, 생산성 또한 향상되는 효과를 누릴 수 있다.

관심사의 분리는 추상화의 일종이다. 대부분의 추상화에서처럼 인터페이스의 추가는 필수이며 실행에 쓰이는 더 순수한 코드가 있는 것이 일반적이다.

## 6\. 권장하는 애플리케이션 설계

구글에서는 다음과 같은 관심사 분리를 통해 애플리케이션을 설계하는 것을 권장한다.

액티비티 또는 프래그먼트는 단지 ViewModel 만을 참조한다. ViewModel 만 참조하여 ViewModel에서 하위 계층의 의존성이 어떻게 변경되는 Activity나 Fragment는 관심이 없다. ViewModel은 Repository라는 저장소를 참조하고 이 저장소로부터 UI 컴포넌트가 화면을 구성하는데 필요한 데이터를 불러온다. 데이터를 불러와 LiveData라는 데이터의 변화를 감지할 수 있는 형태로 관리한다. 저장소는 두 가지 타입의 모델을 참조하는데, 한 가지는 네트워크 연결이 필요 없는 내부 모델이고, 다른 하나는 우리가 일반적으로 서버에서 데이터를 불러오는 네트워크가 필요한 원격 모델이다.

내부 모델은 일반적으로 데이터베이스를 지칭한다. 안드로이드에서 자주 사용하는 데이터베이스 관리 시스템은 프레임워크에 포함된 SQLite나 Room 또는 범용적으로 많이 사용되는 Realm등이 될 수 있다.

원격 모델은 일반적으로 Http 통신이 될 수 있으며, OkHttp 또는 Retorift과 같은 라이브러리가 주로 서버와의 통신에 사용된다.

내부 모델 또는 우너격 모델을 통해 얻은 데이터는 ViewModel에 관리하며 데이터의 변경이 감지되는 대로 UI 컴포넌트의 바인딩된 뷰에 나타낸다. 사용자 경험을 증대시키도록 일반적으로 서버에서 얻은 데이터는 내부 데이터베이스에 저장하여 불러온다.

ViewModel이라는 것은 내부 데이터베이스만을 항상 참조하고, 클라이언트의 데이터베이스와 서버의 데이터베이스가 요청으로 비동기적으로 동기화한다. 이렇게 되면 전파 수신 약전계에서도 애플리케이션은 원할히 동작할 수 있고, 네트워크 상황이 좋아지는 대로 다시 최신의 데이터로 UI 컴포넌트를 갱신할 수 있다.

## 7\. 안드로이드 애플리케이션 설계 패턴

안드로이드의 등장 초기에는 애플리케이션 설계에 대한 관심이 현재와는 상대적으로 적었다. 시간이 지나고 애플리케이션의 성숙과 함께 유지 보수비에 대한 관심이 높아지면서, 이제 막 시작한 프로젝트도 애플리케이션 설계에 대해 고민하게 되었다. 최근에 구글에서도 애플리케이션 설계에 관한 지침, 라이브러리 및 예제를 제공하면서 상황이 많이 좋아졌다. 하지만 여전히 개발자들 사이에는 어떤 방식의 설계가 더 좋은지에 대한 논의가 활발히 이루어지고 있다.

일반적으로 안드로이드 애플리케이션을 설계하는 패턴에는 여러 가지 종류가 있다. 그중 가장 많이 사용되고 비교되는 MVC, MVP, MVVM 디자인 패턴에 대해 알아본다.

### MVC 디자인 패턴

MVC 디자인 패턴은 애플리케이션 구조를 모델, 뷰, 컨트롤러 세 가지 주요 측면으로 관심사를 분리한다. 안드로이드에서 MVC 패턴은 안드로이드 플랫폼의 등장 초기에 애플리케이션을 개발할 때, 어떻게 애플리케이션을 설계해야 하나에 관한 질문들이 자연스럽게 제기되었고, 그 당시 스프링을 비롯한 웹에서 사용하는 가장 유명한 UI 패턴이 MVC라, 많은 개발자는 안드로이드에도 MVC 패턴을 자연스럽게 적용해 왔다.

#### 모델의 역할

애플리케이션의 비즈니스 로직과 사용되는 데이터를 다루는 영역이다. 표현되는 형식에 의존적이지 않고, 사용자에게 보이지 않아 어떻게 보일지를 신경 쓰지 않아도 된다. 일반적으로 비즈니스 데이터는 DBMS에 의해 관리되고 몇몇 함수를 통해 데이터를 제공하거나 입력, 수정 등을 하는 역할을 한다. 안드로이드에서는 데이터베이스의 Entity를 담당하는 POJO클래스를 포함한 SQLite, Room, Realm 등이 될 수 있다.

#### 뷰의 역할

사용자에게 표현되는 영역이다. 모델로부터 얻은 데이터를 뷰에서 표현하며, 안드로이드에서는 Activity, Fragment가 뷰의 역할을 한다.

#### 컨트롤러의 역할

모델과 뷰에 의존한다. 뷰로부터 입력을 받거나 특정 이벤트가 발생할 때 모델 또는 뷰를 변경할 수 있다. 예를 들어 전화번호부 애플리케이션에서 전화번호를 등록한다고 할 떄 사용자가 입력한 전화번호 및 기타 정보를 뷰로부터 입력받으면 컨트롤러는 해당 데이터를 모델로 전달하여 데이터베이스에 입력한다. 이때 모델에 상태가 바뀌면 모델은 등록된 뷰에 자신의 상태가 바뀌었다는 것을 알리고 뷰는 거기에 맞게 사용자에게 모델의 상태를 보여 준다. MVC 디자인 패턴에서 Activity와 Fragmetn는 뷰의 역할을 하지만 컨트롤러의 역할을 하기도 한다.

컨틀롤러는 뷰와 모델에 의존하며, 뷰는 모델의 상태 변화에 따라 능동적으로 대응할 수 있다.

### MVC 디자인 패턴의 장단점

MVC의 가장 큰 장점은 직관적이라는 것이다. 모델에서 데이터를 얻어서 뷰에 표현하고 이 모든 것을 컨트롤러가 중개한다. 구조가 단순하고 직관적이라, MVC를 잘 모르더라도 쉽게 받아들이고 적용할 수 있다.

규모가 작은 애플리케이션에 MVC 디자인 패턴 적용 시 개발 기간이 짧아지고, 거의 모든 코드가 액티비티나 프래그먼트 같은 컨트롤러에 작성되는 경향이 있어 코드를 파악하기가 쉽다. 하지만, 액티비티 또는 프래그먼트가 뷰와 컨트롤러의 역할을 겸하는 구조라 코드량이 점진적으로 증가할 수밖에 없고, 그로 인해 하나의 액티비티 또는 프래그먼트 클래스에서 수천 줄이 넘는 코드가 작성되기도 한다. 이렇게 많은 코드가 하나의 클래스에 작성되면 스파게티 코드가 되기 쉬워, 시간이 지남에 따라 유지 보수비가 증가한다.

컨트롤러는 뷰와 모델에 의존적이고, 뷰와 모델에 의존적이라 결합도가 높아 유닛 테스트가 거의 불가능하다.

### MVP 디자인 패턴

MVC 디자인 패턴에서는 UI와 비즈니스 로직이 Activity와 Fragment에 공존했다. MVP 디자인 패턴에서는 MVC와는 비슷하지만 Activity와 Fragment의 UI 그리고 비즈니스 로직을 분리하는 데 집중하므로 뎅리터의 흐름이 약간 다르다.

Model과 View의 역할을 MVC 디자인 패턴과 동일하다. MVP 디자인 패턴에서는 Controller 대신 Presenter라는 개념을 통해 UI 코드와 비즈니스 로직을 분리하여 유닛 테스트를 할 수 있게 되었다.

### MVP 디자인 패턴의 장단점

Presenter는 View와 Model의 인스턴스를 가지며 이 둘을 연결해 주는 역할을 하므로 Presenter와 View는 1:1 관계를 갖는다.

MVP 디자인 패턴의 장점은 View와 Model 간의 의존성이 없고, UI와 비즈니스 로직을 분리해 유닛 테스트가 수월해진다. 하지만 View와 Presenter 간의 의존성이 높고, 1:1 관계를 유지해야 해서 Presenter를 재사용할 수 없어, View가 늘어날 때마다 Presenter도 같이 늘어나 클래스가 많아진다. 또한 애플리케이션의 기능이 추가될수록 Presenter가 거대해지는 단점이 있다.

### MVP 디자인 패턴 구현하기

#### Contract Class 만들기

MVP 디자인 패턴에서 먼저 해야 할 일은 구성 요소의 역할과 관계의 정의이다. 구성 요소는 보통 View와 Presenter 정도만 정의한다. Model은 Contract클래스에 포함해도 되지만 보통 Repository 패턴으로 따로 정의하여 Presenter를 구현할 때 포함한다.

```java
public class MainContrat{
  public interface View{
    void showPresonList(List<Person> personList);
    void notifyDataChanged();
  }

  public interface Presenter{
    void load();
    void addPerson(Person person);
    void removePerson(Person person);
  }
}
```

#### Presenter Class 만들기

View가 해야 할 역할은 크게 두 가지다.

-   View 인터페이스에 정의된 메서드를 재정의하여 데이터를 화면에 나타낸다.
-   Presenter에 생명 주기 또는 클릭 이벤트에 대한 내용을 통지한다.

일반적으로 View 인터페이스의 구현은 Activity 또는 Fragment에서 이루어진다.  
앞의 예제 코드의 MainContract.View 는 오로지 계약된 MainContract.Presenter에만 참조된다.

```java
public class MainPresenter implements MainContrat.Presenter{

    private Database database;
    private MainContract.View view;

    public MainPresenter(Database database, MainContract.View view){
      this.database = database;
      this.view = view;
      this.database.setOnDatabaseListener(new Database.
      DatabaseListnner(){
        @Override
        public void onChanged(){
          MainPresenter.this.view.notifyDataChanged();
        }
      });
    }
  }

  @Override
  public void load(){
    view.showPresonList(database.getPersonList());
  }

  @Override
  public void addPerson(Person person){
    database,add(person);
  }

  @Override
  public void removePerson(Person person){
    database.remove(person);
  }
}
```

### MVVM 디자인 패턴

MVP 다지인 패턴에서는 Presenter가 View에 어떤 일을 요청하는지 명확하게 확인할 수 있었다. 하지만 View와 Presenter가 강하게 결합하여 있다는 문제점이 있었다. MVVM 디자인 패턴에서는 데이터 바인딩 및 LiveData 또는 RxJava와 같은 Observable 타입을 이용하여 Presenter와 View 사이에서 강하게 연결되었던 점을 끊는 데 집중한다. 이때 Presenter 대신 ViewModel이라는 구성 요소를 사용한다. ViewModel은 View에 표현할 데이터를 Observable 타입으로 관리하며, View들이 ViewModel에 데이터를 구독 요청하여 화면에 나타내느것이 핵심이다. 그러므로 ViewModel과 View는 1:N 관계가 있다.

ViewModel이 View에 대한 의존성을 갖지 않고 느슨하게 연결되도록, Data Binding 라이브러리가 필수적으로 사용된다.

생명 주기 또는 사용자와의 상호 작용 등을 통해 ViewModel은 Model에 데이터를 요청한다. Model로 부터 받은 데이터를 가공하여 Observable한 타입의 형태로 ViewModel에 저장한다. View 와 ViewModel은 Data Binding이 이루어져야 하며, 데이터의 상태가 변경되면 해당 데이터를 구독하는 View들에 변경 사항을 통지하여 View 가 갱신될 수 있도록 한다.

#### ViewModel 구현하기

```java
public class MainViewModel extends BaseObservable{
  private Database database;

  private List<Person> items = new ArrayList<>();

  public MainViewModel(Database database){
    this.database = database;
    this.database.setOnDatabaseListener(new Database.
    DatabaseListnner(){
      @Override
      public void onChanged(){
        load();
      }
    }
  });

  public void load(){
    items.clear();
    items.addAll(database.getPersonList());
    notifyDataChanged();
  }

  public void addPerson(Person person){
    database,add(person);
  }

  public void removePerson(Person person){
    database.remove(person);
  }

  public List<Person> getItems(){
    return items;
  }
}
```
