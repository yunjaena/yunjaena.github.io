---
title: Dagger2를 이용한 의존 - (2)
author: Yun-Jae Na
date: 2020-07-13 18:43:00 +0900
categories: [Android, Dagger2]
tags: [Android, Dagger2]
---

## 6. 모듈

모듈은 컴포넌트에 의존성을 제공하는 역할을 한다. 클래스에 @Module 애노테이션을 붙이는 것으로 간단히 모듈 클래스를 만들 수 있다.

### 프로바이더

모듈 클래스 내에 선언되는 메서드에는 @Provides 애노테이션을 붙이는 것으로 컴파일 타입에 의존성을 제공하는 바인드된 프로바이더를 생성한다. 메서드의 반환형을 보고 컴포너트 내에서 의존성이 관리되어 중복되는 타입이 하나의 컴포넌트 내에 존재하며 안 된다. 예를 들어 하나의 모듈 또는 서로 다른 모듈 내에 반환형을 String으로 갖는 메서드가 두 개 이상 있으면 컴파일 타임에 에러가 발생한다.

```java
@Module
class DuplicationModule{
  @Provides
  String provideHelloWorld(){
    return "Hello World";
  }

  @Provides
  String providCharles(){
    return "Charles"; // 동일한 타입이 2개 이상 존재하므로 에러
  }
}
```

컴포넌트 내 바인드된 메서드의 반환형은 @Provides 메서드의 매개 변수로 사용할 수 있다. 다음 예제를 확인해 본다.

```java
@Module
public class MyModule{
  @Provides
  String provideName(){ // 이름 제공
      return "Charles";
  }

  @Provides
  int provideAge(){ // 나이 제공
    return 100;
  }

  @Provides
  Person providePerson(String name, int age){ // 아름, 나이 제공받음
    return new Person(name, age); //name = Charles , age =100
  }
}
```

providePerson 메서드는 매개 변수로 String 타입과 int 타입을 갖는다. 바로 위에 바인드된 String 타입으로 부터 의존성을 제공받아 name은 Charles가 되고 age는 100이 될 것이다. 매개 변수 타입에 맞는 의존성이 컴포넌트 또는 컴포넌트와 바인드된 모듈에 없다면 에러가 발생한다.

모듈 클래스가 추상 클래스인 경우 @Provides 메서드는 static 메서드여야만 한다.

```java
@Module
public abstract class MyModule{
  @Provides
  static provideName(){
    return "Charles";
  }
}
```

### Null 의 비허용

@Provides 메서드는 null을 반환하는 것을 기본적으로 제한한다. 그러므로 @Provides 메서드에서 null을 반환하는 경우 컴파일 타임에 NullPointerException 을 발생시킨다. @Provides 메서드의 반환값이 null인 것을 명시적으로 허용하려면 메서드에 @Nullable을 추가해야 한다. javax.annotation.Nullable 과 android.support.annotation.Nullable과 관계없이 적용된다.

@Provides 메서드에 @Nullable이 붙였다면, 의존성을 주입받는 부분에도 마찬가지로 @Nullable을 붙여야 한다. 의존성을 제공하는 쪽, 의존성을 주입받는 쪽이 한 쌍으로 @Nullable 애노테이션이 있어야 하며, 한쪽이라도 없으면 컴파일 타임에 에러가 발생한다.

다음 예제는 null을 주입하는 코드다. 한쪽의 @Nullable 을 제거하여 컴파일 에러가 발생하는지 확인해본다.

```java
@Module
public class NullableModule {
    @Provides
    @Nullable // null을 반환할 가능성이 있는 경우
    Integer provideInteger(){
        return null;
    }
}
```

```java
@Component(modules = NullableModule.class)
public interface NullableComponent {
    @Nullable // 이 애노테이션이 없으면 에러가 발생한다.
    Integer getInteger();
}
```

프로비전 메서드뿐만 아니라 멤버-인젝션 메서드를 써서 null을 주입하는 경우에도 멤버 변수에 @Nullable 을 꼭 붙여야 한다.

### 모듈의 상속

@Module 애노테이션이 가질 수 있는 속성 중 includes라는 것이 있다. includes에 다른 모듈 클래스들의 배열을 정의하는 것만으로 @Provides 메서드의 상속이 가능하다. 예를 들어 ModuleA와 ModuleB가 MoudleA를 상속하는 코드는 다음과 같다.

```java
@Module
public class ModuleA{
  @Provides
  A provideA(){
    return new A();
  }
}

@Module(includes = ModuleA.class)
public class ModuleB(){
  @Provides
  B provideB(){
    return new B();
  }
}
```

컴포넌트를 선언할 때 ModuleB를 참조하는 경우 Module A를 상속해 A 타입의 객체도 바인딩된다. 주의해야 할 점은 모듈 간 상속을 할 때 중복되는 타입이 존재하면 안된다는 것이다. 이 점을 주의해서 모듈을 설계한다면, 보일러 플레이트 코드를 많이 제거할 수 있을 것이다.

## 7. 컴포넌트

컴포넌트는 바인딩된 모듈로부터 오브젝트 그래프를 생성하는 핵심적인 역할을 한다. @Component 사용을 통해 컴포넌트를 생성할 수 있으며, @Component 애노테이션은 interface또는 abstract 클래스에서만 붙일 수 있다. 컴파일 타임의 애노테이션 프로세서에 의해 생성된 클래스는 접두어 'Dagger'와 @Component 가 붙은 클래스 이름이 합쳐진 형식의 이름을 갖는다.

@Comopnent 속성으로 modules와 dependencies가 있다. 앞에서 살펴보았듯이 modules에는 컴포넌트에 바인드되는 @Module이 지정된 클래스 배열을 선언한다. 모듈이 다른 모듈을 포한하는 경우 컴포넌트에 선언된 모듈뿐만 아니라 포함된 모듈도 컴포넌트에 구현될 수 있도록 해야 한다. dependencies에는 컴포넌트에 다른 컴포넌트의 의존성을 사용하는 경우 클래스 배열을 선언한다.

### 오브젝트 그래프

Dagger에서는 컴포넌트, 모듈, 객체 등의 관계를 컨테이너 또는 오브젝트 그래프라고 한다. 짧게 표현해서 그래프라고 하는 경우도 있다.

### 컴포넌트 메서더

@Component 가 붙은 모든 타입은 최소한 하나의 추상적인 메서드를 가져야 한다. 메서드의 이름은 상관없지만. 메서드 매개 변수와 반환형은 규칙을 엄격하게 따라야 한다. 이렇게 정해진 규칙에 따라 프로비전 메서드와 멤버-인젝션 메서드로 구분된다.

### 프로비전 메서드 (Provision methods)

Dagger의 컴포넌트에서 매개 변수를 갖지 않으면서 반환형은 모듈로부터 제공되거나 주입되는 메서드를 프로비전 메서드라고 칭한다.

```java
@Component(modules = SomeModule.class)
public interface SomeComponent{
  SomeType getSomeType();
}
```

### 멤버-인젝션 메서드 (Member-injection methods)

Dagger의 컴포넌트에서는 하나의 매개 변수를 갖는 메서드를 멤버-인젝션 메서드라고 칭한다. 멤버-인젝션 메서드는 void를 반환하거나 빌더 패턴처럼 메서드 체이닝이 가능한 메서드를 만들기 위해 매개 변수 타입을 반환형으로 갖는 메서드로 선언할 수 있다. 다음과 같은 멤버-인젝션 메서드를 컴포넌트 내에 선언할 수 있다.

```java
@Component(modules = SomeModule.class)
public interface SomeComponet{
  void injectSomeType(SomeType someType);

  SomeType injectAndReturnSomeType(SomeType someType);
}
```

앞의 Hello World 예제를 조금 수정하여 멤버-인젝션 메서드를 구현해 본다. 먼저 의존성을 주입받도록 MyClass를 만든다. 의존성 주입을 받을 필드에 @Inject 애노테이션을 붙인다.

```java
public class MyClass{
  @Inject
  String str;

  public String getStr(){
    return str;
  }
}
```

MyComponent 에도 다음과 같이 멤버-인젝션 메서드를 추가한다.

```java
@Component(modules = MyModule.class)
public interface MyComponent{
  void inject(MyClass myClass);
}
```

멤버-인젝션이 잘 되는지 확인하려면 다음과 같이 테스트해 본다.

```java
@Test
public void testMemberInjection(){
  MyClass myClass = new MyClass();
  String str = myClass.getStr();
  assertNull("조회 결과 null", str); // null임을 확인
  MyComponent myComponent = DaggerMyComponet.create();
  myComponent.inject(myClass);
  str = myClass.getStr();
  assertEquals("hello world", str); //str = hello wold
}
```

MyComponet.ineject(MyClass) 메서드를 호출하기 전에는 myClass의 필드가 null이었다가 메서드 호출 이후에는 "hello world"가 주입된 것을 확인할 수 있다. 멤버-인젝션 메서드에 의해 필드 주입이 일어난 결과이다.

매개 변수가 없고 MembersInjection 객체의 injectmembers(T) 메서드를 호출하면 멤버-인젝션 메서드와 동일한 작업을 수행한다.

컴포넌트에 다음과 같인 MembersInjector를 반환하는 메서드를 추가한 뒤 테스트 해본다.

```java
@Component
public interface MyComponent{
  ...
  MembersInjector<MyClass> getInjector();
}
```

```java
@Test
public void testMemberInjector(){
  MyClass myClass = new MyClass();
  String str = myClass.getStr();
  System.out.println("result = " + str); // str = null
  MyComponent myComponent = DaggerMyComponent.create();
  MembersInjector<MyClass> injector = myComponent.getInjector();
  injector.injectMembers(myClass);
  str = myClass.getStr();
  System.out.println("result = " + str); // str != null
}
/*
실행 결과
result = null
result = Charles
*/
```

### 의존성 주입하기

Dagger에서는 3가지 의존성 주입 방법을 제공한다.

-   필드 주입
-   생성자 주입
-   메서드 주입

@Inject 애노테이션이 붙은 필드, 메서드 또는 생성자에 인스턴스를 주입하는데, 실무에서는 필드 주입과 생성자 주입이 주로 사용된다.

간단한 예제를 통해 필드, 생성자, 메서드 주입을 살펴본다.

```java
@Component(modules = PersonModule.class)
public interface PersonComponent{

  PersonA getPersonA(); // 프로비전 메서드

  void inject(PersonB perosnB); // 멤버-인젝션 메서드
}
```

```java
@Module
public class PersonModule{
  @Provides
  String provideName(){
    return "Charles";
  }

  @Provides
  int provideAge(){
    return 100;
  }
}
```

```java
public class PersonA{
  private String name;
  private int age;

  @Inject
  public PersonA(String name, int age){
    this.name = name;
    this.age = age;
  }

  public String getName(){
    return name;
  }

  public int getAge(){
    return age;
  }
}
```

```java
public class PersonB{
  @Inject
  String name;

  private int age;

  @Inject
  public void setAge(int age){
    this.age = age;
  }

  public String getName(){
    return name;
  }

  public int getAge(){
    return age;
  }
}
```

이름과 나이를 제공하는 PersonModule을 PersonComponent에 추가하고, PersonA 객체를 제공하는 프로비전 메서드와 PersonB에 멤버-인젝션을 하는 메서드를 추가했다. PersonA에는 생성자 주입을 할 것이고, PersonB에는 필드 주입과 메서드 주입을 동시에 수행할 것이다.

```java
@Test
public void testInjection(){
  PersonComponent personComponent = DaggerPersonComponent.create();

  PersonA personA = personComponent.getPersonA();
  System.out.println(presonA.getName() + ":" + personA.getAge());

  PersonB personB = new PersonB();
  DaggerPersonComponent.create().inject(personB);
  assertEquals("Charles", personB.getName()); // 이름

  assertEqulas(100, personB.getAge()); // 나이
}
/* 실행 결과
Charles:100
Charles:100
*/
```

### 상속된 클래스에 의존성 주입

멤버-인젝션 메서드를 호출할 떄 매개 변수 타입에 서브 클래스(자식 클래스)의 객체를 넣으면 해당 슈퍼 클래스의 @Inject 멤버만 의존성 주입이 이루어진다. 예를 들어 컴포넌트에 멤버-인젝션 메서드인 inject(Self)가 존재하고, Child의 인스턴스를 멤버-인젝션 메서드의 매개 변수로 참조하여 메서드를 호출하면 Child의 인스턴스에는 a와b만 주입되고 c에는 주입되지 않는 것을 확인할 수 있다.

```java
public class Parent{
  @Inject
  A a;
}
```

```java
public class Self extends Parent{
  @Inject
  B b;
}
```

```java
public class Child extends Self{
  @Inject
  C c;
}
```

### 컴포넌트 객체 만들기

컴포넌트를 객체화할 때는 주로 생성된 빌더나 팩토리를 통해 만들 수 있다. 컴포넌트내의 @Component.Builder 또는 @Component.Factory 타입 선언을 통해 빌더 또는 팩토리가 생성되는데, 빌더나 팩토리 애노테이션이 둘 다 존재하지 않으면 Dagger는 @Component 애노테이션에 선언된 모듈 및 의존성을 참조하여 빌더를 자동으로 생성한다. HelloWorld 예제에서도 빌더 및 팩토리를 선언하지 않아 자동으로 빌더를 생성했다. 빌더가 어떻게 생성되는지 궁금하면, 생성된 DaggerMyComponent의 내부를 살펴보는 것도 좋은 방법이다.

만약 MyComponent의 빌더 구조를 직접 작성해야 한다면 다음과 같이 작성할 수 있다.

```java
@Component(modules = MyModule.class)
public interface MyComponent{
  ...
  @Component.Builder
  interface Builder{
    Builder setMyModule(MyModule myModule);
    MyComponent build();
  }
}
```

```java
@Test
public void builderTest(){
    MyComponent myComponent = DaggerMyComponent.builder().setMyModule(new MyModule()).build();
    System.out.println(myComponent.getString());
    myComponent = DaggerMyComponent.create();
    System.out.println(myComponent.getString());
}
```

빌더와 팩토리를 생성하는 규칙은 매우 엄격하며 다음과 같은 조건이 반드시 성립해야 한다.

### 컴포넌트 빌더를 만드는 조건

-   @Component.Builder 애노테이션은 컴포넌트 타입 내에 선언되어야 한다.
-   반드시 매개 변수를 가지 않고, 컴포넌트 타입 또는 컴포넌트의 슈퍼 타입을 반환하는 추상 메서드를 하나 포함해야 한다. 이를 빌드 메서드(build method)라고 한다.
-   빌드 메서드를 제외한 나머지는 세터 메서드(setter methods)라고 한다.
-   @Component 애노테이션에 modules, dependencies로 선언된 요소들은 세터 메서드로 선언해야 한다.
-   세터 메서드는 반드시 하나의 매개 변수만 가져야 하며, 반환형으로는 void, 빌더 또는 빌더의 슈퍼 타입이 될 수 있다.
-   세터 메서드에 @BindsInstance를 붙이면, 해당 컴포넌트에 인스턴스를 넘겨 바인드 시킨다.

앞의 조건들을 충족시키는 컴포넌트 빌더의 예시는 다음과 같다.

```java
@Component(modules = {BackendModule.class, FrontendModule.class})
interface MyComponent{
  MyWidget myWidget();

  @Component.Builder
  interface Builder{
    Builder backendModule(BackendModule bm);
    BUilder forntendModule(FrontedModule fm);
    @BindsInstnace
    Builder foo(Foo foo);
    MyComponent build();
  }
}
```

### 컴포넌트 팩토리를 만드는 조건

-   @Component.Factory 애노테이션은 컴포넌트 타입 내에 선언되어야 한다.
-   컴포넌트 팩토리는 컴포넌트 타입 또는 컴포넌트의 슈퍼 타입을 반환하는 하나의 추상 메서드만 존재해야 한다. 예) newInstance(...)
-   팩토리 메서드에는 @Component 애노테이션에 modules, dependencies로 지정된 속성들을 반드시 매개 변수로 가여야 한다.
-   메서드 @BindsInstance 애노테이션이 붙은 매개 변수는 해당 컴포넌트에 인스턴스를 넘겨 바인드시킨다.

생성되는 컴포넌트 타입에는 factory()라는 정적 메서드를 갖는데 팩토리 인스턴스를 반환한다. 이 팩토리 인스턴스로 컴포넌트를 초기화할 수 있다.

앞의 조건들을 충족시키는 컴포넌트 팩토리의 예시는 다음과 같다.

```java
@Component(modules = {BackendModule.class, FrontendModule.class})
interface MyComponent{
  MyWidget myWidget();

  @Component.Factory
  interface Factory{
    MyComponent newMyComponent(
      BackendModule bm,
      FrontendModule fm,
      @BindInstance Foo foo
    );
  }
}
```
