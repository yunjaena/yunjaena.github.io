---
title: Dagger2를 이용한 의존 - (1)
author: Yun-Jae Na
date: 2020-07-08 18:43:00 +0900
categories: [Android, Dagger2]
tags: [Android, Dagger2]
---

## 1. 의존성 주입이란?

소프트웨어 공학에서 말하는 의존성 주입(DI, Dependency Injection)이란 하나의 객체에 다른 객체의 의존성을 제공하는 기술을 말한다. 의존성은 객체 지향에서 두 클래스 간의 관계이다. 일반적으로 둘 중 하나가 다른 하나를 필요로 한다. 조립식 컴퓨터를 생각하며 다음 의존 관계에 대한 예제를 살펴본다.

```java
public class CPU}{}

public class Computer{

    private CPU cpu;

    public Computer(){
        cpu = new Computer();
    }
}
```

컴퓨터에 포함하는 CPU가 컴퓨터가 생성되는 단계부터 단단히 결합한 모습을 보인다. 다른 CPU로 업그레이드하고 싶어도 변경할 수 없다. 이를 "Computer가 CPU에 의존성을 갖는다."라고 할 수 있다.

주입은 생성자나 메서드 등을 통해 외부로부터 생성된 객체를 전달받는 것을 의미한다. 다음 예제를 살펴본다.

```java
public class Computer{

  private CPU cpu;

  public void setCPU(CPU cpu){
    this.cpu = cpu;
  }
}
```

setCPU(CPU) 메서드를 통해 외부로부터 생성된 객체를 전달받아 멤버 변수에 넣는다. 앞에서 설명한 의존성과 주입을 합쳐 보면 "의존 관계에 있는 클래스의 객체를 외부로부터 생성하여 주입받는다."라고 말할 수 있다.

## 2. 의존성 주입의 필요성

의존성 주입의 필요성에 대해 알아보고 의존성 주입에 대한 이해도를 높여 본다.

### 변경 전이

다시 한 번 컴퓨터와 CPU의 관계를 확인해 본다. 'Computer'는 'CPU'라는 한 가지 타입에 의존한다. 하지만 사용자는 다른 타입의 CPU를 사용하는 것을 원할 수 있다. 예를 들어 A사의 CPU로 컴퓨터를 조립하기 원한다면 기존 CPU 클래스명을 A_CPU로 변경하거나 새로 만들어야 한다. 하나의 클래스를 변경하거나 새로 만든느 것은 어렵지 않다. 여기서 문제점은 CPU 클래스를 의존하던 Computer 클래스도 같이 변경해야 한다는 점이다.

```java
public class Computer{
  private A_CPU cpu; // 변경됨

  public Computer(){
    cpu = new A_CPU(); // 변경됨
  }
}
```

하나의 클래스를 변경함으로써 다른 의존 관계까지 변경 사항이 전이된다.

이를 해결할 방법은 Computer가 의존하는 CPU를 interface로 만드는 것이다. CPU를 구현한 어떤 클래스 간에 Computer의 CPU로 가능할 수 있다.

```java
public interface CPU {...}

private CPU cpu;

public class Computer{
  private CPU cpu;
  public Computer(){
    cpu = new A_CPU();
    // cpu = new I_CPU();
  }
}
```

하지만 여전히 문제점은 남아 있다. CPU를 인터페이스로 변경함에 따라 변경의 전이를 최소화했지만, Computer 클래스에서 CPU 객체를 생성하고 관리해 I 회사의 CPU를 사용한다면 또다시 Computer 클래스를 변경해야 한다.

### 제어의 역전 (IoC, Inversion of Control)

제어의 역전은 어떠한 일을 수행하도록 만들어진 프레임워크에 제어권을 위임함으로써 관심사를 분리하는 것을 의미한다. 제어의 역전을 통해 앞의 코드들의 문제점을 해결해 본다.

```java
public class Computer{
  private CPU cpu;

  public Computer(){}

  public Computer(CPU cpu){
    this.cpu = cpu;
  }

  public void setCPU(CPU cpu){
    this.cpu = cpu;
  }
}

public static void main(String[] args){
  CPU cpu = new I_CPU;
  Computer computer1 = new Computer(cpu);
  // 또는
  Computer computer2 = new Computer();
  computer2.setCPU(cpu);
}
```

Computer 클래스의 생성자에서 CPU 객체를 만들지 않고, 외부로 부터 CPU 객체를 생성한 뒤 Computer 생성자 또는 메서드의 매개 변수로 객체를 제공한다. 기존에는 Computer가 CPU의 객체를 생성하고 관리했으나 개선된 코드에서는 CPU 객체의 생성 및 관리를 외부에 위임했다. 이를 제어의 역전이라고 한다. 제어의 역전을 통해 결합도를 약하게 만들었고, Computer는 이제 CPU의 변경 사항에 의해 내부 필드나 메서드 매개 변수를 변경하지 않아도 된다.

### 의존성 주입의 장단점

의존성 주입은 다음과 같은 장점이 있다.

-   의존성 주입은 인터페이스를 기반으로 설계되며, 코드를 유연하게 한다.
-   주입하는 코드만 따로 변경하기 쉬워 리팩토링이 수월하다.
-   의존성 주입을 사용하는 결과로 stub나 mock 객체를 사용하여 단위 테스트를 하기가 더욱 쉬워진다. 의존성 주입의 가장 큰 장접으로 꼽힌다.
-   클래스 간의 결합도를 느슨하게 한다.
-   인터페이스를 기반으로 설계하므로 여러 개발자가 서로 사용하는 클래스를 독립적으로 개발할 수 있다. 즉, 클래스 간에 의존하는 인터페이스만 알면된다.

반면에 의존성 주입을 사용하면 다음과 같은 단점이 있다

-   간단한 프로그램을 만들 때는 번거롭다.
-   의존성 주입은 동작과 구성을 분리해 코드를 추적하기 어렵게 하고, 가독성을 떨어트릴 수 있다. 즉, 개발자는 더 많은 파일을 참조해야만 한다.
-   Dagger2와 같은 의존성 주입 프레임워크는 컴파일 타임에 애노테이션 프로세서스를 이용하여 파일을 생성하므로 빌드에 시간이 조금 더 소요된다.

짧은 기간 개발하고, 더는 유지 보수를 안 하는 간단한 프로그램을 만드는 경우에는 의존성 주입의 사용을 굳이 추천하지 않는다. 왜냐하면 의존성 주입을 하려고 인터페이스 기반으로 설계하고, 의존성 주입 프레임워크의 설정 등이 생산성을 떨어뜨리기 떄문이다. 하지만 일반적인 상용 애플리케이션을 만들고, 지속해서 유지 보수를 할 경우에는 오히려 생산성을 향상한다.

의존성 주입을 사용하는 경우 코드 추적이 힘들어지고, 대표적 의존성 주입 도구인 Dagger2 사용 시 빌드 시간이 조금 더 소요된다는 단점도 있다. 하지만 적응하고 나면 코드 추적은 그렇게 어렵지 않고, Dagger2를 사용하여 다른 부분에서 크게 시간을 절약할 수 있어 오히려 Dagger2를 사용하지 않는 것보다 사용하는 편이 시간을 더 절약할 수 있다.

## 3. Dagger2란 무엇인가?

Dagger2는 자바와 안드로이드를 위한 강력하고 빠른 의존성 주입 프레임워크다. 리플렉션을 사용하지 않고, 런 타입에 바이트 코드도 생성하지 않는 것이 특징이다. 컴파일 타임에 애노테이션 프로세서에 의해 의존성 주입과 관련된 모든 코드를 분석하고 자바 소스 코드를 생성한다. Dagger가 등장하기 전 자바 진영에서 쓰이던 Guice가 있었으나 리플렉션을 사용하고, 런 타임에 오브젝트 그래프를 구성하는 등 성능에 악영향을 끼치는 요소가 많았다. 결국 애노테이션을 기반으로 코드를 생성하며, Guice와 비슷한 API를 갖지만 조금 더 빠른 Dagger1이 2012년 Square사에 의해 등장한다. 이후 Square사의 Dagger 최초 개발자와 구글의 코어 라이브러리 팀이 Dagger2를 만들고 현재까지 빠르게 발전시켜 왔다.

Dagger를 프로젝트에 적용한다는 것은 쉬운 일이 아니다. 가파른 학습 곡선으로 인해 배우려다가 중도 포기하는 경우도 있다. 아마도 다음과 같은 이유로 인해 Dagger가 어렵다고 느낄 것 같다.

-   애노테이션 기반의 코드 생성 방식이 익숙하지 않은 사람은 내부가 어떤 식으로 동작하는지 유추하기 힘들다.
-   다른 DI 라이브러리보다 공부해야 할 부분이 더 많다.
-   Component, Subcomponent, Module 등과 같은 Dagger에서만 사용하는 용어로 인해 혼란스럽다.

Dagger의 장점을 정리하면 다음과 같다.

-   자원 공유의 단순화, 지정된 범위의 생명 주기 내에서 동일 인스턴스를 제공한다.
-   복잡한 의존성을 단순하게 설정함. 애플리케이션이 커질수록 많은 의존성을 자는데 Dagger는 이를 쉽게 제어해 준다.
-   유닛 테스트를 쉽게 도와준다.
-   자동 코드 생성, 생성된 코드는 명확하고 디버깅이 가능하다.
-   Dagger2는 난독화 문제가 없다. Dagger1은 리플렉션의 사용으로 인해 런타임에 성능 및 난독화와 관련된 문제가 발생했다.
-   라이브러리 크기가 작다.

## 4. 프로젝트에 Dagger 설정하기

안드로이드 스튜디오 프로젝트에서 Dagger를 적용하려는 모듈의 build.gradle에 다음과 같은 내용을 추가한다.

-   **app/build.gradle**

    ```groovy
    dependencies{
      implementation 'com.google.dagger:dagger-android:2.27'
      implementation 'com.google.dagger:dagger-android-support:2.27'
      annotationProcessor 'com.google.dagger:dagger-android-processor:2.27'
      annotationProcessor 'com.google.dagger:dagger-compiler:2.27'
    }
    ```


몇몇 프로젝트에서는 하위의 의존하는 모듈을 참조하려고 implementation 대신 api를 사용해야 할 수도 있다.

코틀린 언어를 사용하는 프로젝트에서는 다음과 같이 annotationProcessor를 kapt로 변경해야 한다.

```groovy
dependencies{
    implementation 'com.google.dagger:dagger-android:2.27'
    implementation 'com.google.dagger:dagger-android-support:2.27'
    kapt 'com.google.dagger:dagger-android-processor:2.27'
    kapt 'com.google.dagger:dagger-compiler:2.27'
}
```

최신 버전의 라이브러리 사용을 권장하며, 2020년 7월 8일 기준으로 2.28.1 버전이 최신 버전이다. 최신 버전 및 Dagger2에 대해 더 자세한 정보를 얻으려변 [Dagger github link](https://github.com/google/dagger) 를 참고한다.

만약 안드로이드 데이터 바인딩 라이브러리를 사용하는 경우 데이터 바인딩 오류가 발생했을 때 javac에 의해 오류 메시지를 출력한다. 데이터 바인딩과 Dagger를 같이 사용하면, Dagger와 관련된 오류 발생 시 데이터 바인딩에 대한 컴파일이 멈추고, 오류 메시지 또한 100줄 이상 출력되므로, 에러 메시지를 더 확인하려면 다음과 같은 코드를 추가로 설정해야 한다.

-   **app/build.gradle**

    ```groovy
    android{
    ...
    gradle.projectsEvaluated{
      tasks.withType(JavaCompile){
        options.compilerArgs << "-Xmaxerrs" << "500"
      }
    }
    }
    ```


찾는 오류 메시지가 500줄 이내에 없다면 "500"을 더 큰 숫자로 변경한다.

## 5. 첫 번째 의존성 주입 구현하기

때로는 이론보다 실습에 익히는 것이 빠를 때도 있다. 간단히 "Hello World" 문자열 주입 예제를 통해 기본적인 Dagger 사용법을 익혀 본다.  
우선 안드로이드 스튜디오를 실행하고 새로운 안드로이드 프로젝트를 생성하낟. 앞의 '프로젝트에 Dagger 설정하기' 를 참고하여 app 모듈에 Dagger2를 적용한다.

프로젝트에 Dagger의 설정을 끝냈다면 이제 "Hello World" 문자열을 제공할 모듈을 만들 차례다. 다음과 같은 MyModule 클래스를 작성한다.

```java
@Module
public class MyModule{
  @Provides
  String provideHelloWorld(){
    return "Hello World";
  }
}
```

앞에서 언급했듯이 Dagger는 컴파일러 타임의 의존성 주입에 필요한 애노테이션을 읽고 의존성 주입에 필요한 클래스 파일들을 생성한다. Dagger는 컴파일 타임에 @Module과 @Provides 애노테이션을 읽고 의존성 주입에 필요한 파일들을 생성한다.

각각의 애노테이션의 용법에 대해 간단히 설명하자면 @Module 은 의존성을 제공하는 클래스에 붙이고 @Provides는 의존성을 제공하는 메소드에 붙인다고 생각하면 된다. 그러므로 MyModule 클래스는 의존성을 제공하는 클래스이고, provideHelloWorld() 메서드는 String 타입의 Hello World 문자열을 제공하는 것을 뜻한다.

MyModule 클래스 하나만으로는 별도의 클래스 파일이 생성되지는 않는다. 모듈을 참조하는 컴포넌트가 없기 때문이다. 이제 컴포넌트를 만들어 본다.

```java
@Component(modules = MyModule.class)
public interface MyComponent{
  String getString(); // 프로비전 메서드, 바인드된 모듈로부터 의존성을 제공
}
```

@Component 가 붙은 MyComponent 인터페이스 내에는 제공할 의존성들을 메서드로 정의해야 하며, @Component 에 참조된 모듈 클래스로부터 의존성을 제공받는다. 컴포넌트 메서드의 반환형을 보고 모듈과 관계를 맺으므로 바인드된 모듈로부터 해당 반환형을 갖는 메서드를 찾지 못한다면 컴파일 타임에 에러가 발생한다.

Dagger는 컴파일 타임에 @Component를 구현한 클래스를 생성하는데, 이때 클래스의 이름은 'Dagger'라는 접두어가 붙는다. 예를 들어 MyComponent라는 컴포넌트를 만들었다면. Dagger에 의해 생성된 클래스 이름은 DaggerMyComponent가 된다.

이제 Dagger에 의해 생성된 클래스를 통해 의존성을 제공받아 본다.

안드로이드 프레임워크에 대한 의존성이 없으므로, JUnit 테스트 클래스 작성을 통해 의존성이 제대로 제공되는지를 확인해 본다.

단위 테스트가 익숙하지 않다면, 안드로이드의 TextView에서 결과를 확인해도 된다.

```java
public class ExampleUnitText{
  @Test
  public void testHelloWorld(){
    MyComponent myComponent = DaggerMyComponent.create();
    System.out.println("result = " + myComponent.getString());
  }
}

// 실행 결과 => result = Hello World
```

Hello World가 출력되었다면 의존성 주입의 구현을 성공한 것이다. 컴포넌트와 모듈만 사용하여 아주 간단한 예제를 만들어 보았다.
