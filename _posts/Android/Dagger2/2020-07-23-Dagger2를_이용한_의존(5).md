---
title: Dagger2를 이용한 의존 - (5)
author: Yun-Jae Na
date: 2020-07-23 13:34:00 +0900
categories: [Android, Dagger2]
tags: [Android, Dagger2]
---

## 13. 컴포넌트 간의 의존 관계

지금까지는 하나의 컴포넌트만 생성하는 예제를 다루었지만, 다수의 컴포넌트를 생성하고 상호 간의 의존 관계를 맺을 수도 있다. Dagger에서는 컴포넌트 간의 의존 관계를 맺는 데 서브 컴포넌트와 컴포넌트 상속 두 가지 방법을 제공한다.

### 서브 컴포넌트

두 개의 컴포넌트를 연관 짓는 가장 쉬운 방법은 서브 컴포넌트를 선언하는 것이다. 서브 컴포넌트는 컴포넌트와 아주 비슷한 방식으로 동작하지만 상위 컴포넌트 내에 구현된다는 점에서 일반 컴포넌트와 다르다. 여기서 말하는 상위 컴포넌트는 컴포넌트가 될 수도 있고, 서브 컴포넌트가 될 수도 있다. 다시 말하자면 서브 컴포넌트 내에 다른 서브 컴포넌트를 구현하는 것이 가능하다. 서브 컴포넌트는 상위 컴포넌트의 바인딩된 모든 의존성을 제공 받는다. 하지만 상위 컴포넌트가 하위 컴포넌트의 의존성을 제공받을 수 없다.

### 서브 컴포넌트 정의

컴포넌트를 만들 때와 마찬가지로 추상 클래스 또는 인터페이스에 @Component 대신 @SubComponent 를 붙아는 것으로 서브 컴포넌트를 정의할 수 있다. 마찬가지로 @Subcomponent 속성의 modules에 바인딩하려는 모듈 클래스들을 추가한다. **서브 컴포넌트를 만들려면 빌더 또는 팩토리를 반드시 정의해야 한다.**

서브 컴포넌트의 이해를 돕고자 서브 컴포넌트를 활요한 카페 예제를 하나 만들어 본다. 카페를 가면 에스프레소 머신이 있고, 이 머신에 커피콩과 물을 더해 커피를 만들 수 있다. 카페 쪽이 컴포넌트가 되고, 에스프레소 머신 쪽이 서브 컴포넌트가 될 것 이다. 먼저 서브 컴포넌트를 정의해 본다.

```java
@Subcomponent(modules = MachineModule.class)
public interface MachineComponent{
  Coffee getCoffee();
  void inject(Machine machine);

  @Subcomponent.builder
  interface Builder{
    Builder setMachineModule(MachineModule coffeeMachineModule);
    MachineComponent build();
  }
}
```

```java
public class Coffee{
  @Inject
  public Coffee(CoffeeBean coffeeBean, Water water){...}
}
```

```java
public class Machine{
  private MachineComponent component;
  public Machine(MachineComponent.Builder builder){
    component = builder.setMachineModule(new MachineModule())
                     .build();
    component.inject(this);
  }

  public Coffee extract(){
    return component.getCoffee();
  }
}
```

```java
@Module
public class MachineModule{
  @Provides
  CoffeeBean provideCoffeeBean(){
    return new CoffeeBean();
  }
}
```

```java
public class CoffeeBean{...}
```

Machine을 위한 서브 컴포넌트가 준비되었다.

### 서브 컴포넌트 추가

서브 컴포넌트인 MachineComponent를 정의했다면 컴포넌트에 서브 컴포넌트로 추가해야 한다. 컴포넌트를 추가하려면 컴포넌트가 가진 @Module의 멤버인 subcomponents에 서브 컴포넌트 클래스를 추가해야 한다. 서브 컴포넌트가 연결되었다면, 연결된 컴포넌트 모듈로부터 서브 컴포넌트의 빌더를 요청할 수 있다.

```java
@Component(modules = CafeModule.class)
public interface CafeComponent{
  void inject(Cafe cafe);
}
```

```java
public class Cafe{
  @Inject
  Machine coffeeMachine;

  public Cafe(){
    DaggerCafeComponent.create().inject(this);
  }

  public Coffee orderCoffee(){
    return coffeeMachine.extract();
  }
}
```

```java
@Module(subcomponents = MachineComponent.class)
public class CafeModule{
  @Provides
  Water provideWater(){
    return new Water();
  }

  @Provides
  Machine provideMachine(MachineComponent.Builder builder){
    return new Machine(builder);
  }
}
```

```java
public class Water{...}
```

컴포넌트에 연결된 CafeModule로부터 Machine을 제공받을 수 있게 되었고, Machine의 생성자 매개 변수로는 서브 컴포넌트로부터 빌더를 제공받아 객체를 생성하는 것을 확인할 수 있다.

이제 카페에 커피를 주문해 본다.

```java
public class CoffeeUnitTest{
  @Test
  public void testCafe(){
    Cafe cafe = new Cafe();
    System.out.println(cafe.orderCoffee());
    System.out.println(cafe.orderCoffee());
    System.out.println(cafe.orderCoffee());

  }
}
```

### 서브 컴포넌트의 특징

MachineComponent는 CafeComponent의 일부분으로 CafeComponent가 가진 CafeModule로부터 모듈이 가진 의존성을 제공받을 수 있지만, CafeComponent는 MachineComponent.Builder를 제외하고는 서브 컴포넌트가 가진 모듈의 의존성을 제공받을 수 없다.

서브 컴포넌트는 독립적인 생명 주기를 갖는다. 컴포넌트가 존재하는 동안 서브 컴포넌트는 생성과 소멸을 반복할 수 있는 것이 특징이다. 컴포넌트가 소멸하면 서브 컴포넌트도 같이 소멸한다.

### 컴포넌트의 상속

서브 컴포넌트는 오브젝트 그래프 내의 하위 그래프를 작성하는 가장 간단한 방법이지만 서브 컴포넌트는 부모 컴포넌트와 밀접하게 연결되어 분리가 어렵다. 서브 컴포넌트의 대안으로 컴포넌트의 상속이 있다. 컴포넌트가 다른 컴포넌트를 상속하는 방법이다. 컴포넌트를 상속하는 방법은 @Component 애노테이션의 dependencies 속성에 상속하려는 컴포넌트의 클래스를 추가하면 된다. 상속한 컴포넌트의 의존성을 사용하려면 상속한 컴포넌트가 해당 의존성을 프로비전 메서드로 반드시 제공해야 한다. 다음 예제를 통해 컴포넌트를 상속하는 방법을 확인한다. 먼저 두 개의 다른 컴포넌트를 준비해야 한다.

```java
@Component(modules = ModuleA.class)
public interface ComponentA{
  String provideString(); // 프로비전 메서드
}
```

```java
@Module
public class MoudleA{
  @Provides
  String provideString(){
    return "String from ModuleA";
  }
}
```

```java
@Component(
modules = ModuleB.class,
dependencies = ComponentA.class
)
public interface ComponentB{
  void inject(Foo foo);
}
```

```java
@Module
public class ModuleB{
  @Provides
  Integer provideInteger(){
    return 100;
  }
}
```

```java
public class Foo{
  @Inject
  public String str;

  @Inject
  public Integer integer;
}
```

각각의 컴포넌트는 서로 다른 모듈에 의존하고, ComponentB는 ComponentA를 상속하는 모습이다. ComponentA의 프로비전 메서드로 provideString을 선언하였으며, ComponentB는 ComponentA로부터 String 타입의 의존성을 제공받을 수 있다. 테스트를 통해 컴포넌트 상속이 제대로 이루어졌는지 확인해 본다.

```java
@Test
public void testDependency(){
  Foo foo = new Foo();
  ComponentA componentA = DaggerComponentA.create();
  ComponentB componentB = DaggerComponentB.builder()
          .componentA(componentA)
          .build();
  compoentB.inject(foo);
  System.out.println(foo.str); // String Frrom ModuleA
  System.out.println(foo.integer); // 100
}
```

실행 결과

```
String from ModuleA
100
```

## 14\. 안드로이드와 Dagger2

### 안드로이드를 위한 기본적인 접근 방식

안드로이드에 Dagger를 사용하려면 안드로이드의 다음 특성에 대해 먼저 이해해야 한다. 첫째, 안드로이드는 하나의 애플리케이션 내에서 액티비티 또는 서비스 같은 생명 주기를 갖는 컴포넌트로 구성된다. 둘째, 프래그먼틑는 단족으로 존재할 수 없으며, 반드시 액티비티 내에 존재한다. 샛째, 애플리케이션을 포함한 액티비티 또는 서비스와 같은 컴포넌트는 시스템에 의해서만 인스턴스화 된다.

애플리케이션의 생명 주기 동안 다양한 액티비티 및 서비스가 생성과 소멸을 반복할 수 있고, 하나의 액티비티 내에서는 마찬가지로 여러 프래그먼트가 생성과 소멸을 반복할 수 있다. 가장 큰 범위인 애플리케이션에서 일어나는 일들이므로 애플리케이션 생명 주기와 Dagger 컴포넌트의 생명 주기를 같이하는 애플리케이션 컴포넌트를 만든다. 액티비티 또는 서비스를 위한 Dagger 컴포넌트는 애플리케이션 컴포넌트의 서브 컴포넌트로 구성하고, 프래크먼트는 액티비티(서브) 컴포넌트의 서브 컴포넌트로 다시 지정한다.

애플리케이션 컴포넌트 생성을 위한 AppComponent 코드는 다음과 같다.

```java
@Component(modules = AppModule.class)
@Singleton
public interface AppComponent{
  MainActivityComponent.Builder mainActivityComponentBuilder();
  void inject(App app);

  @Component.Factory
  interface Factory{
    AppComponent create(
      @BindsInstance App app,
      AppModule appModule
    );
  }
}
```

```java
@Module(subcomponents = MainActivityComponent.class)
public class AppModule{
  @Provides
  @Singleton
  SharedPreferences provideSharedPreferences(App app){
    return app.getSharedPreferences(
          "default",
          Context.MODE_PRIVATE
    );
  }
}
```

AppComponent는 빌더 또는 팩토리를 통해 생성되는데 AppComponent에서는 팩토리를 정의했다. 팩토리에서 create 메서드의 매개 변수로 애플리케이션 컴포넌트의 모듈로 AppModule과 애플리케이션 클래스인 App을 받는다.

```java
public class App extends Application{

  private AppComponent appComponent;

  @Override
  public void onCraete(){
    super.onCreate();
    appComponent = DaggerAppComponent.factory()
                    .create(this, new AppModule());
  }

  public AppComponent getAppComponent(){
    return appComponent;
  }
}
```

App 클래스를 매니페스트에 등록하는 것을 잊지 않도록 한다.

```xml
<manifest ...>
  <application
      ...
      android:name=".App">
      ...
  </application>
</manifest>
```

애플리케이션 인스턴스는 시스템에 의해서만 생성될 수 있어 애플리케이션이 생성된 후 팩토리의 @BindsInstance 메서드를 통해 오브젝트 그래프에 바인딩 한다.

AppModule 에서는 애플리케이션의 생명 주기 동안 싱글턴으로 취급할 SharedPreference를 제공하며, 싱글턴이 아닌 매번 인스턴스를 생성하거나 시스템으로부터 가져오고 싶다면 @Singleton 애노테이션을 제거하면 된다.

액티비티를 위한 컴포넌트는 서브 컴포넌트로 구성해야 하므로 서브 컴포넌트의 클래스를 애플리케이션 모듈의 멤버로 추가했다. 서브 컴포넌트와 서브 컴포넌트의 빌더가 정의되었다면, 컴포넌트에서는 서브 컴포넌트의 빌더를 반환하는 프로비전 메서드를 가질 수 있다.

다음 MainActivity를 위한 서브 컴포넌트 클래스를 살펴본다.

```java
@SubComponent(modules = MainAcitivtyModule.class)
@ActivityScope
public interface MainAcitivityComponent{
  MainFragmentComponent.Builder mainFragmentComponentBuilder();

  void inject(MainAcitivty activity);

  @Subcomponent.Builder
  interface Builder{
    Builder setModule(MainActivityModule module);
    @BindsInstance
    Builder setActivity(MainActivity activity);
    MainActivityComponent build();
  }
}
```

```java
@Module(subcomponent = MainFragment.class)
public class MainActivityModule{
  @Provides
  @ActivityScope
  String provideActivityName(){
    return MainActiviy.class.getSimpleName();
  }
}
```

애플리케이션과 범위를 구분 짓도록 사용자 정의 한정자인 @ActivityScope를 사용했다. 이로써 MainActivityModule 내의 @ActivityScope를 가진 바인딩 메서드들은 액티비티 생명 주기 동안 동일한 인스턴스 제공을 보장받을 수 있다.

애플리케이션과 마찬가지로 액티비티 인스턴스 또한 시스템에 의해서 생성되므로 액티비티의 생명 주기 콜백 내에서 서브 컴포넌트 빌드 시 바인딩할 수 있도록 @BindsInstance 세터 메서드를 통해 액티비티 인스턴스를 바인딩한다.

액티비티를 위한 컴포넌트 모듈에서는 프래그먼트를 위한 서브 컴포넌트를 추가했다.

```java
public class MainActivity extends AppCompatActivity{
  @Inject
  SharedPreferences sharedPreferences;

  @Inject
  String activityName;

  MainActivityComponent component;

  @Override
  protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstance);
    setContentView(R.layout.activity_main);

    component = ((App)getApplication()).getAppComponent()
                      .mainAcitivityComponentBuilder()
                      .setModule(new MainActivityModule())
                      .setAcitivty(this)
                      .build();
    component.inject(this);

    getSuppoortFragmentManger().beginTransaction()
              .replace(R.id.container, new MainFragment())
              .commit();
  }

  public MainActivityComponent getComponent(){
    return component;
  }
}
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
      xmlns:android="http://schemas.android.com/apk"
      xmlns:app="http://schemas.android.com/apk/res-auto"
      xmls:tools="http://schemas.android.com/tools"
      android:layout_width="match_parent"
      andorid:layout_height="match_parent"
      tools:context=".MainActivity">


<FrameLayout
  android:id="@+id/container"
  android:layout_width="0dp"
  android:layout_height="0dp"
  app:layout_constraintStart_toStartOf="parent"
  app:layout_constraintEnd_toEndOf="parent"
  app:layout_constraintTop_toTopOf="parent"
  app:layout_constraintENd_toEndOf="parent"
  />

</androidx.constraintlayout.widget.ConstraintLayout>
```

앞의 코드는 애플리케이션으로부터 AppComponent 인스턴스를 가져와서 MainActivityComponent.Builder를 제공받아 액티비티 모듈과 인스턴스를 바인딩하고 MainActivityComponent를 생성한 뒤 의존성을 주입하는 모습이다. 애플리케이션 컴포넌트로부터 SharedPreference를 주입받고, 액티비티 컴포넌트로부터 String 객체를 주입받았다.

프래그먼트도 액티비티와 동일하게 서브 컴포넌트를 정의한 후 프래그먼트 범위 내에서 의존성을 주입할 수 있다. 다음 프래그먼트 컴포넌트와 모듈 코드를 확인한다.

```java
@FragmentScope
@Subcomponent(modules = MainFragmentMoudle.class)
public interface MainFragmentComponent{
  void inject(MainFragment mainFragment);

  @Subcomponent.Builder
  interface Builder {
    MainFragmentComponent.Builder setModule(MainFragmentModule module);
    @BindsInstance
    MainFragmentComopnent.Builder setFragment(MainFragment fragment);
    MainFragmentComponent build();
  }
}
```

```java
@Module
public class MainFragmentModule {
  @Provides
  @FragmentScope
  Integer provideInt(){
    return new Random().nextInt();
  }
}
```

```java
public class MainFragment extends Fragment {
  @Inject
  SharedPreferences sharedPreferences;

  @Inject
  String activityName;

  @Inject
  Integer randomNumber;

  @Override
  public void onAttach(Context context) {
    super.onAttach(context);
    if(getActivity() instanceof MainActivity){
      ((MainActivity)getActivity)).getComponent()
                .mainFragmentComponentBuilder()
                .setModule(new MainFragmentModule())
                .setFragment(this)
                .build()
                .inject(this);
    }

    Log.d("MainFragment", activityName);
    Log.d("MainFragment", "randomNumber = " + randomNumber);
  }
}
```

앱을 빌드하고 실행한 뒤 로그 캣을 확인하면 다음과 같은 로그가 출력된다.

```java
D/MainFragment : MainActivity
D/MainFragment : randomNumber = 1541652
```

### 보일러 플레이트 코드 제거

#### `android.dagger.* 패키지 활용하기`

앞에서 안드로이드를 위한 오브젝트 그래프를 설계하는 방법에 대해서 알아보았다. 하지만 여기에는 다음과 같은 문제점들이 있다.

-   비슷한 형태의 반복되는 보일러 플레이트 코드들이 생성된다.
-   리팩토링이 쉽지 않다.
-   멤버 주입 메서드의 매개 변수로 정확한 타입을 알아야 한다.

이러한 문제점들을 해결하도록 Dagger에서는 안드로이드를 위한 dagger.android 패키지를 제공한다. 액티비티에 의존성을 주입한다고 가정하고 기존 코드를 다시 고쳐 본다.

가장 먼저 해야 할 일은 AndroidInjectionModule을 추가하는 것이다. AndroidInjectionModule에는 안드로이드 프레임워크 관련 클래스에 의존성 주입을 위임할 AndroidInjector<?>의 택토리를 멀티 바인딩으로 관리한다.

AndroidInjectionModule과 AndroidInjector를 구현한 AppComponent의 모습은 다음과 같다.

```java
@Singleton
@Component(modules = {AndroidInjectionModule.class, AppModule.class})
public interace AppComponent extends AndroidInjector<App> {

  @Component.Factory
  interface Factory extends AndroidInjector.Factory<App>{

  }
}
```

AndroidInjector는 멤버 인젝션을 위한 inject() 메서드가 포함되고, AndroidInjector.Factory는 App 인스턴스를 그래프에 바인딩하고 Component를 반환하는 create() 메서드가 이미 포함되어 있으므로 별도로 정의할 필요는 없다.

AppModule에서는 MainActivity의 인스턴스에 멤버 인젝션을 담당할 MainActivitySubcomponent를 서브 컴포넌트로 연결한다.

```java
@Module(subcomponents = MainActivitySubcomponent.class)
public abstract class AppModule{
  @Named("app")
  @Provides
  @Singleton
  static String provideString(){
    return "String from AppModule";
  }

  @Binds
  @IntoMap
  @ClassKey(MainActivity.class)
  abstract AndroidInjector.Factory<?> bindAndroidInjectorFactory(MainActivitySubcomponent.Factory factory);
}
```

@Singleton 스코프에서 의존성을 주입하는지 확인하도록 문자열을 하나 반환하는 프로바이드 메서드를 정의했다.

bindAndroidInjectionFactory 메서드는 AndroidInjectionModule 내부에 있는 Map에 AndroidInjector.Factory를 멀티 바인딩한다. 이로써 서브 컴포넌트들이 편하게 멤버 인젝션을 할 수 있도록 인젝터 팩토리들을 멀티 바인딩으로 관리한다.

```java
public class App extends Application implements HasAndroidInjector {

  @Inject
  DispatchingAndroidInjector<Object> dispatchingAndroidInjector;

  @Override
  public void onCraete(){
    super.onCreate();
    DaggerAppComponent.factory()
              .create(this)
              .inject(this);
  }

  @Override
  public AndroidInjector<Object> androidInjector(){
    return dispatchingAndroidInjector;
  }
}
```

MainActivity의 의존성 주입을 담당할 MainActivitySubcomponent와 MainActivity Module을 다음과 같이 선언한다.

```java
@ActivityScope
@Subcomponent(modules = {MainAcitivityModule.class})
public interface MainActivitySubcomponent extends AndroidInjector<MainActivity>{

  @Subcomponent.Factory
  interface Factory extends AndroidInjector.Factory<MainActivity>{

  }
}
```

```java
@Module(subcomponents = MainFragmnetSubcomponent.class)
public abstract class MainActivityModule {

  @Named("activity")
  @Provides
  @ActivityScope
  static String provideString(){
    return "String from MainActivityModule";
  }

  @Binds
  @IntoMap
  @ClassKey(MainFragment.class)
  abstract AndroidInjector.Factory<?> bindInjectorFactory(MainFragmentSubcomponent.Factory factory);
}
```

MainActivitySubcomponent는 AppComponent에 포함되는 서브 컴포넌트이므로 @Subcomponent 애노테이션을 선언하였다.

MainActivitySubcomponent가 서브 컴포넌트지만 자신의 하위에 다시 서브 컴포넌트를 가질 수 있다. MainFragment에 멤버 인젝션을 하기 위한 MainFragmentSubcomponent를 연결했다.

@ActivityScope에서 문자열을 제공하는 프로바이드 메서드를 하나 선언했으며, 마찬가지로 MainFragment를 위한 인젝터 팩토리를 멀티 바인딩한다.

모든 준비가 끝났다면 액티비티에서 super.onCreate() 메서드를 호출하기 전에 AndroidInjection.inject()를 호출하도록 한다.

```java
public class MainActivty extends AppCompactActivity implements HasAndroidInjector {
  @Inject
  DispatchingAndroidInjector<Object> androidInjector;

  @Inject
  @Named("app")
  String appString;

  @Inject
  @Named("activity")
  String activityString;

  @Override
  protected void onCreate(Bundle savedInstanceState){
    AndroidInjection.inject(this);
    Log.e("MainActivity", appString);
    Log.e("MainActivity", activityString);
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    getSupportFragmentManager().beginTransaction()
              .replace(R.id.container, new MainFragment())
              .commit();
  }

  @Override
  public AndroidInjector<Object> androidInjector(){
    return androidInjector;
  }
}
```

AndroidInjection.inject()를 호출하면 APP으로부터 DispatchingAndroidInjector를 얻고 이를 통해 MainActivty에 맞는 AndroidInjector.Factory를 클래스 이름을 통해 찾는다. 팩토리를 통해 생성된 MainActivitySubcomponent는 액티비티에서 호출한 inject()를 통해 의존성 주입이 완료된다.

멤버 인젝션 이후 로그가 잘 출력되는지 확인한다.

프래그먼트의 경우도 액티비티 오브젝트 그래프를 형성하는 것과 다르지 않다. 서브 컴포넌트를 정의하고 액티비티와 똑같은 방식으로 주입하면 된다. MainFragment용 서브 컴포넌트와 모듈을 정의해 본다.

```java
@FragmentScope
@Subcomponent(modules = MainFragmentModule.clss)
public interface MainFragmentSubcomponent extends AndroidInjector<MainFragment> {
  @Subcomponent.Factory
  interface Factory extends AndroidInjector.Factory<MainFragmnet>{
  }
}
```

```java
@Module
public class MainFragmentModule{
  @Named("fragment")
  @Provides
  @FragmentScope
  String provideString(){
    return "String from fragment";
  }
}
```

다만 액티비티는 onCreate() 호출 시점에서 주임하는 데 반해 프래그먼트는 onAttach()에서 super.onAttach()가 호출되기 전에 주입하면 된다.

```java
public class MainFragment extends Fragment{
  @Inject
  @Named("app")
  String appString;

  @Inject
  @Named("activity")
  String activityString;

  @Inject
  @Named("fragment")
  String fragmentString;

  @Override
  public void onAttach(Context context){
    AndroidSupportInjection.inject(this);
    Log.e("MainFragment", appString);
    Log.e("MainFragment", activityString);
    Log.e("MainFragment", fragmentString);
    super.onAttach(context);
  }
}
```

앱을 빌드 후 실행한 다음 로그가 출력되는지 확인한다.

```
E/MainActivity: String from AppModule
E/MainActivity: String from MainActivityModule
E/MainFragment: String from AppModule
E/MainFragment: String from MainActivityModule
E/MainFragment: String from fragment
```

### @ContributesAndroidInjector 애노테이션 활용하기

만약 서브 컴포넌트의 팩토리가 다른 메서드나 클래스를 상속하지 않는다면 @ContirbutesAndroidInjector를 활용해 서브 컴포넌트를 정의하는 코드를 대체함으로써 서브 컴포넌트를 위한 보일러 플레이트 코드를 더 줄일 수 있다.

@ContirbutesAndroidInjector 애노테이션을 활용한 전체 소스 코드를 확인하고 앞에서 다룬 코드와 무엇이 다른지 확인해본다.

```java
@Singleton
@Component(modules = {AndroidInjectionModule.class, AppModule.class})
public interface AppComponent extends AndroidInjector<App> {

    @Component.Factory
    interface Factory extends AndroidInjector.Factory<App> {
    }
}
```

```java
@Module
public abstract class AppModule {
    @Named("app")
    @Provides
    @Singleton
    static String provideString(){
        return "String from AppModule";
    }

    @ActivityScope
    @ContributesAndroidInjector(modules = MainActivityModule.class)
    abstract MainActivity mainActivity();

}
```

```java
public class App extends DaggerApplication {

    @Override
    protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
        return DaggerAppComponent.factory()
                .create(this);
    }
}
```

```java
@Module
public abstract class MainActivityModule {
    @Named("activity")
    @Provides
    @ActivityScope
    static String provideString() {
        return "String from MainActivityModule";
    }

    @FragmentScope
    @ContributesAndroidInjector(modules = MainFragmentModule.class)
    abstract MainFragment mainFragment();
}
```

```java
public class MainActivity extends DaggerAppCompatActivity {
    @Inject
    @Named("app")
    String appString;

    @Inject
    @Named("activity")
    String activityString;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        AndroidInjection.inject(this);
        Log.e("MainActivity", appString);
        Log.e("MainActivity", activityString);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.container, new MainFragment())
                .commit();
    }
}
```

```java
@Module
public class MainFragmentModule {
    @Named("fragment")
    @Provides
    @FragmentScope
    String provideString() {
        return "String from fragment";
    }
}
```

```java
public class MainFragment extends DaggerFragment {
    @Inject
    @Named("app")
    String appString;

    @Inject
    @Named("activity")
    String activityString;

    @Inject
    @Named("fragment")
    String fragmentString;

    @Override
    public void onAttach(@NonNull Context context) {
        AndroidSupportInjection.inject(this);
        Log.e("MainFragment", appString);
        Log.e("MainFragment", activityString);
        Log.e("MainFragment", fragmentString);
        super.onAttach(context);
    }
}
```

DaggerApplication을 상속한 App 클래스를 작성함면 applicationInjector() 메서드를 구현해야 하는데, 이때 애플리케이션 컴포넌트를 반환시키는 코트를 작성하기만하면 기존의 모든 코드를 대체할 수 있다.

액티비티 상속 클래스 또한 DaggerActivity 또는 DaggerAppCompactActivity 같은 타입을 사용하면 HasAndroidInjector를 따로 구현할 필요가 없다.

```java
public class MainActivity extends DaggerAppCompatActivity{
  @Inject
  SharedPreferences sharedPreferences;

  @Inject
  String activityName;

  @Overrid
  protected void onCreate(Bundle savedInstanceState){
    super.onCraete(savedInstanceState);
    setContentView(R.layout.activity_main);
    getSupportFragmentManger().bieginTransaction()
                .replace(R.id.container, new MainFragment())
                .commit();
  }
}
```

Dagger는 이외에도 다음과 같은 기본 프레임워크 타입을 지원한다.

-   DaggerApplication
-   DaggerActivity
-   DaggerFragment
-   DaggerService
-   DaggerIntentService
-   DaggerBroadcastReceiver
-   DaggerContentProvider

DaggerBroadCastReceiver를 사용하는 경우 Androidmanifest.xml에 브로드캐스트 리시버가 등록되어야 하며 직접 리시버 인스턴스를 생성하는 경우 생성자 주입을 사용해야 한다.
