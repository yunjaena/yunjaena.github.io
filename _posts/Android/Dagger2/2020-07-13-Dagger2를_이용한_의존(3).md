---
title: Dagger2를 이용한 의존 - (3)
author: Yun-Jae Na
date: 2020-07-14 17:53:00 +0900
categories: [Android, Dagger2]
tags: [Android, Dagger2]
---

## 8. Lazy 주입과 Provider 주입

Lazy 타입 또는 Provider타입을 사용한다면, 상황에 따라 의존성 주입의 시점을 늦추거나 새로운 객체를 요청할 수도 있다.

### Lazy 주입

객체가 초기화되는 데 시간이 필요하다면 Lazy 주입을 고려해 볼 수 있다. 방법은 간단하다. 바인드된 타입 (T)을 제네릭으로 갖는 Lazy 타입을 만들면 된다. Lazy의 get() 메서드를 호출하기까지는 객체가 초기화되는 것을 늦출 수 있다. 다음 예제를 살펴본다.

```java
@Component(modules = CounterModule.class)
public interface CounterComponent{
  void inject(Counter counter);
}
```

```java
@Module
public class CounterModule{
  int next = 100;

  @Provides
  Integer provideInteger(){
    System.out.println("computing...");
    return next++;
  }
}
```

```java
public class Counter{
  @Inject
  Lazy<Integer> lazy;

  public void printLazy(){
    System.out.println("printing...");
    System.out.println(lazy.get());
    System.out.println(lazy.get());
    System.out.println(lazy.get());
  }
}
```

```java
@Test
public void testLazy(){
  CounterComponent component = DaggerCounterComponent.create();
  Counter counter = new Counter();
  component.inject(counter);
  counter.printLazy();
}
```

printLazy()를 호출한 결과는 다음과 같다.

```
printing...
computing...
100
100
100
```

### Provider 주입

매번 새로운 인스턴스를 주입받고 싶다면 Provider를 고려해볼 수 있다. Lazy와 마찬가지로 바인드된 타입(T)을 제네릭으로 갖는 Provider의 get() 메서드 호출할 때마다 새로운 객체를 제공받는다.

```java
public class Counter{

  @Inject
  Provider<Integer> provider;

  public void printProvider(){
    System.out.println("printing...");
    System.out.println(provider.get());
    System.out.println(provider.get());
    System.out.println(provider.get());
  }
}
```

Lazy에서 사용하던 예제에 필드와 메서드만 추가했다. printProvider()를 호출한 결과는 다음과 같다.

```
printing...
computing...
100
computing...
101
computing...
102
```

매 Provider.get() 메서드 호출 시 새로운 객체를 생성하므로 computing... 문구와 카운트가 1씩 증가하는 결과를 나타낸다.

컴포넌트가 @Singleton 과 같은 특정 범위로 지정되었다면, Provider를 사용한다고 하더라도 바인드된 의존성은 싱글턴으로 관리되어 같은 인스턴스를 제공받는다.

## 9\. 한정자 지정하기

### @Named 사용하기

때로 반환형으로 바인드된 객체를 식별하기에는 충분하지 않을 수 있다. 예를 들어 하나의 컴포넌트에 바인드되면서 String을 반환하는 @Provides 메서드가 두 개 이상인 경우를 생각해 본다. Dagger 입장에서는 어느 쪽을 바인딩해야 할지 애매모호해져 에러를 발생시킨다. 에러가 발생하는 아래의 예제를 살펴본다.

```java
@Module
public class MyModule{
  @Provides
  String provideHello(){
    return "Hello";
  }

  @Provides
  String provideWorld(){
    return "World";
  }
}
// String 타입을 반환하는 메서드가 두 개이므로 에러
```

상황에 따라 반환형이 같은 두 개 이상의 @Provides 메서드를 바운드해야 할 수도 있다. 그럴 땐 javax.inject 패키지에서 제공하는 @Named 애노테이션을 통해 같은 타입의 의존성을 식별할 수 있다. 사용 방법은 매우 간단하다. @Named 애노테이션의 멤버값에 식별 가능한 문자열을 넣기만 하면 된다.

```java
@Component(modules = MyModule.class)
public interface MyComponent{
  void inject(MyClass myClass);
}
```

```java
@Moudle
public class MyModule{
  @Provides
  @Named("hello")
  String provideHello(){
    return "Hello";
  }

  @Provides
  @Named("world")
  String provideWorld(){
    return "World";
  }
}
```

@Named 의 속성으로 각각 hello와 world를 지정했다. 이제 같은 타입이지만 한정자로 구분할 수 있게 된 것이다. 의존성을 주입받는 곳에서도 @Named 를 다음과 같이 지정해야 한다.

```java
public class MyClass{
  @Inject
  @Named("hello")
  String strHello;

  @Inject
  @Named("world")
  String strWorld;

  public String getStrHello(){
    return strHello;
  }

  public String getStrWorld(){
    return strWorld;
  }
}
```

```java
@Test
public void myComopnet(){
  MyClass myClass = new MyClass();
  DaggerMyComponet.create().inject(myClass);
  System.out.println(myClass.getStringHello());
  System.out.println(myClass.getStrWorld());
}
```

실행 결과

```
Hello
World
```

### 사용자 정의 한정자 만들기

@Named가 아닌 고유 한정자를 만들 때, @Qualifier 를 사용하여 직접 한정자를 만들수도 있다.

```java
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Hello{
}
```

```java
@Module
public class MyModule{
  @Provides
  @Hello
  String provideHello(){
    return "Hello";
  }

  @Provides
  String providWorld(){
    return "World";
  }
}
```

```java
public class MyClass{
  @Inject
  @Hello
  String strHello;

  @Inject
  String strWorld;
}
```

```java
@Test
public void myComponent(){
  MyClass myClass = new MyClass();
  DaggerMyComponent.create().inject(myClass);
  System.out.println(myClass.getStrHello());
  System.out.println(myClass.getStrWolrd());
}
```

실행 결과

```
Hello
World
```

## 10. 범위 지정하기

각 컴포넌트는 @Scope 애노테이션과 함께 범위를 지정할 수 있다. 컴포넌트의 구현과 함께 각 컴포넌트 인스턴스는 의존성의 제공 방법에 대한 동일성을 보장받을 수 있다. 쉽게 말해 하나의 인스턴스만 만들어서 참조하는 싱글턴 패턴과 비슷한 개념이지만, 애플리케이션 생명 주기와 달리 생명 주기를 따로 관리할 수 있다는 점에서 차이가 있다. 예를 들어 안드로이드에서는 애플리케이션, 액티비티, 프래그먼트 인스턴스에 대한 범위 지정을 다르게 관리함으로써 오브젝트 그래프의 생성과 소멸을 각자 관리할 수 있다.

### Singleton 사용하기

일반적으로 @Singleton 애노테이션을 사용하여 범위를 지정하여 객체를 재사용할 수 있따. 다음 @Singleton 애노테이션을 추가한 예제를 살펴본다.

```java
@Singleton
@Component(modules = MyModule.class)
public interface MyComponet{
  Object getObject();
}
```

```java
@Module
public class MyModule{
  @Provides
  @Singleton
  Object provideObject(){
    return new Object();
  }
}
```

컴포넌트와 @Provides 메서드에 @Singleton을 추가했다. 이제 테스트 코드를 작성하여 동일한 인스턴스를 제공받을 수 있는지 확인해 본다.

```java
@Test
public void testObjectIdentify(){
  MyComponent myComponent = DaggerMyComponent.create();
  Object temp1 = myComponent.getObject();
  Obejct temp2 = myComponent.getObject();
  System.out.println(temp1.hashCode());
  System.out.println(temp2.hashCode());
  assertNotNull(temp1);
  assertNotNull(temp2);
  assertSame(temp1, temp2);
}
```

실행 결과

```
326549596
326549596
true
```

### @Reusable 사용하기

@Reusable 도 @Singleton 을 비슷한 다른 커스텀 스코프와 비슷한 역할을 한다. 특정 컴포넌트 스코프에 종속되지 않아 컴포넌트에 @Resuable 을 선언하지 않아아도 된다. 이전 객체를 재사용 가능하다면 재사용하고 아니면 새로 생성한다. 즉, 다른 스코프 애노테이션처럼 인스턴스의 동일성을 보장하진 않지만, 항상 동일한 인스턴스를 사용해야 하는게 아니라면 메모리 관리 측면에서 조금 더 효율적이다.

### @Scope 확장하기

다음 예제처럼 커스텀 스코프를 직접 만들어 컴포넌트의 범위를 지정할 수도 있다.

```java
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface UserScope{
}
```

```java
@Module
public class MyModule{
  @Provides
  @UserScope
  Object providObject(){
    return new Object();
  }
}
```
