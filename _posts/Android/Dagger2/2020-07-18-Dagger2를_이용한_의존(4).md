---
title: Dagger2를 이용한 의존 - (4)
author: Yun-Jae Na
date: 2020-07-18 04:12:00 +0900
categories: [Android, Dagger2]
tags: [Android, Dagger2]
---

## 11. 바인딩의 종류

### @Binds

@Binds 애노테이션은 모듈 내의 추상 메서드에 붙일 수 있으며, 이 메서드는 반드시 하나의 매개 변수만을 가져야 한다. 매개 변수를 반환형으로 바인드할 수 있으며, @Provides 매서드 대신 좀 더 효율적으로 사용할 수 있다. 다음 예제를 통해 @Binds 용법을 확인할 수 있다.

```java
@Binds
abstract Random bindRandom(SecureRandom secrueRandom);
```

이미 바인드된 SecureRandom을 Random 타입으로 한 번 더 바인드할 수 있다.

@BindsOptionalOf

@BindsOptionalOf 애노테이션은 모듈 내의 추상 메서드에 붙일 수 있으며, 이 메서드는 매개 변수를 가질 수 없다. void가 아닌 특정 타입을 반환형으로 가져야 하며, 예외 사항을 던질 수도 없다. 다음과 같은 @BindsOptionalOf 메서드가 있다고 가정해 본다.

```java
@Module
public abstract class CommonModule{
  @BindsOptionalOf
  abstract String bindsOptionalOfString();
}
```

```java
@Module
public class HelloModule{
  @Provides
  String providString(){
    return "Hello";
  }
}
```

@BindsOptionalOf 메서드를 통한 의존성의 주입은 다음과 같은 Optional 타입 등으로 주입된다.

```java
public class Foo{
  @Inject
  public Optional<String> str; // @Nullable 바인딩은 허용하지 않음

  @Inject
  public Optional<Proivder<String>> str2;

  @Inject
  public Optional<Lazy<String>> str3;
}
```

만약 컴포넌트 내에 Foo가 바인드된 적이 있다면 Optional의 상태는 present이고, 그렇지 않다면 absent이다.

이와 같이 어떤 타입의 의존성이 바인드되었는지 여부와 관계없이 @Inject를 이용해 주입할 수 있는 것이 특징이다.

Optional은 null을 포함하는 것을 허용하지 않는다. 그러므로 @Nullable 바인딩에 대해서는 컴파일 타임에 에러를 발생시킨다.

바인드 유무에 따른 Optional 상태 테스트를 위해 두개의 컴포넌트를 생성해 본다.

```java
@Component(modules = {ComonModule.class, HelloModule.class})
public interface StrComponent{
  void inject(Foo foo);
}
```

```java
@Component(modules = CommonModule.class)
public interface NoStrComponent{
  void inject(Foo foo);
}
```

하나의 컴포넌트는 String 의존성을 제공하는 HelloModule을 추가하고 다른 하나의 컴포넌트는 HelloModule을 추가하지 않는다.

```java
@Test
public void testFoo(){
  FOo foo = new Foo();

  DaggerStrComponent.create().inject(foo);
  System.out.println(foo.str.isPresent());
  Systme.out.println(foo.str.get());

  DaggerNoStrComponent.create().inject(foo);
  System.out.println(foo.str.isPresent());
  System.out.println(foo.str.get());
}
```

실행결과

```
true
Hello
false
java.util.NoSuchElementException : No value present
```

Optional 타입인 foo.str 이 String이 바인드되었을 때는 present 상태이고 String이 바인드되지 않았을 떄는 absent인 것을 확인할 수 있으며, absent 상태일 때 get() 메서드로 값을 참조하면 에러가 발생하는 것도 확인할 수 있다.

### @BindsInstance

@BindsInstance 애노테이션은 컴포넌트 빌더의 세터 메서드 또는 컴포넌트 팩토리의 매개 변수에 붙일 수 있다. 모듈이 아닌 외부로부터 생성된 인스턴스를 빌더 또는 팩토리를 통해 넘겨줌으로써 컴포넌트가 해당 인스턴스를 바인드하게 된다. 이러한 인스턴스들은 모듈로부터 제공되는 인스넌스와 동일하게 @Inject가 붙은 필드, 생성자, 메서드에 주입될 수 있다. 다음 예제를 통해 String 객체가 어떻게 바인드되는지 확인한다.

```java
@Component
public interface BindsComponent{
  void inject(Foo foo
  @Component.Builder{
    @BindsInstance
    Builder setString(String str);
    BindsComponent build();
  }
}
```

```java
public class Foo{
  @Inject
  public String str;
}
```

Builder를 만들고 @BindsInstance 가 붙은 setString 세터 메서드를 추가했다. 이 세터 메서드에 외부로부터 생성한 String 객체를 바인드할 것이다. 다음 유닛 테스트를 통해 결과를 확인해 볼 수 있다.

```java
@Test
public void testBindsInstance(){
  String hello = "Hello World";
  Foo foo = new Foo();
  BindsComponent component = DaggerBindsComponent.builder()
        .setString(hello)
        .build();
  component.inject(foo);
  asserEquals("Hello World", foo.str);
}
```

실행결과

```
Hello World
```

## 12\. 멀티 바인딩하기

Dagger의 멀티 바인딩을 사용하여 여러 모듈에 있는 같은 타입의 객체를 하나의 Set 또는 Map 형태로 관리할 수 있다.

### Set 멀티 바인딩

Set로 멀티 바인딩을 구현하려면 @IntoSet 과 @ElementsIntoSet 애노테이션을 @Prvides 메서도와 함께 사용할 수 있다. 먼저 @IntoSet 예제를 살펴본다.

```java
@Module
public class SetModule{
  @Provides
  @IntoSet
  String provideHello(){
    return "Hello";
  }

  @Provides
  @IntoSEt
  String provideWorld(){
    return "World"
  }
}
```

간단히 @IntoSet를 사용하는 것으로 Set 타입으로 멀티 바인딩이 구현된다. 객체를 하나씩 Set에 추가하는 것이 아니라 Set의 일부분을 한꺼번에 추가할 수 있는데, 이떄는 @ElementsIntoSet 애노테이션을 사용한다. 다음 에제를 확인해본다.

```java
@Module
public class SetModule{
  ...
  @Provides
  @ElementsIntoSet
  Set<String> proivdeSet(){
    return new HashSet<>(Arrays.asList("Charles", "Runa"));
  }
}
```

Set로 멀티 바인딩이 잘 구현되었는지 확인하려면 다음과 같이 SetComponent와 멀티 바인드된 의존성을 주입하는 Foo 클래스를 만든다.

```java
@Component(modules = SetModule.class)
public interface SetComopnent{
  void inject(Foo foo);
}
```

```java
public class Foo{
  @Inejct
  Set<String> strings;

  public void print(){
    for(Interator itr = strings.iterator(); itr.hasNext();){
      System.out.println(itr.next());
    }
  }
}
```

테스트 코드를 통해 결과를 확인한다.

```java
public class MultibindingTest{
  @Test
  public void testMultibindingSet(){
    Foo foo = new Foo();
    DaggerSetComponent.create().inject(foo);
    foo.print();
  }
}
```

실행 결과

```
Charles
Runa
Hello
World
```

### Map 멀티 바인딩

Map으로 멀티 바인딩을 구현하려면 모듈 내의 @Provides 메서드에 @IntoMap을 추가해야 한다. 주의해야 할 점은 Map을 사용하는 데는 키(Key)가 필요해 @IntoMap 애노테이션과 함께 별도의 키 애노테이션을 추가해야 한다.

### 기본 제공하는 키의 종류

맵을 위한 Dagger에서 기본 제공하는 키로는 @StringKey, @ClassKey, @IntKey, @LongKey 가 있다.

다음 예제를 통해 기본적인 키로 어떻게 멀티 바인드를 구현하는지 확인한다.

```java
public class Foo{
}
```

```java
@Module
public class MapModule{
  @Provides
  @IntoMap
  @StringKey("foo")
  static Long provideFooValue(){
    return 100L;
  }

  @Provides
  @IntoMap
  @ClassKey(Foo.class)
  static String provideFooStr(){
    return "Foo String";
  }
}
```

```java
@Component(modules=MapModule.class)
public interface MapComponent{
  Map<String, Long> getLongsByString();
  Map<Class<?>, String> getStringsByClass();
}
```

```java
public class MultibindingMapTest{
  @Test
  public void testMultibindingMap(){
    MapComponent component = DaggerMapComponent.create();
    long value = component.getLongsByString().get("foo");
    String str = component.getStringsByClass().get(Foo.class);

    System.out.println(value);
    System.out.println(str);
  }
}
```

실행 결과

```
100
Foo String
```

모듈 내의 @Provides 메서드에 붙은 키가 Map의 키가 되고 메서드를 통해 반환된는 값을 통해 한 쌍의 키-값을 이루는 것을 확인할 수 있다. 다음 예제와 같이 @MapKey 애노테이션을 통해 사용자 정의 키를 선언해본다.

```java
public enum Animal{
  CAT, DOG;
}
```

```java
@MapKey
public @interface AnimalKey{
  Animal value();
}
```

```java
@MapKey
public @interface NumberKey{
  Class<? extends Number> value();
}
```

AnimalKey와 NumberKey 두 가지 키를 만들었다. AnimalKey는 열거형이 Animal 타입을 속성으로 갖고, NumberKey는 Number 클래스의 서브 클래스 타입을 속성으로 갖는다.

```java
@Component(modules = MapModule.class)
public interface MapKeyComponet{
  Map<Animal, String> getStringsByAnimal();

  Map<Class<? extends Number>, String> getStringsByNumber();
}
```

```java
@Module
public class MapModule{
  @IntoMap
  @AnimalKey(Animal.CAT)
  @Provides
  String provideCat(){
    return "Meow";
  }

  @IntoMap
  @AnimalKey(Animal.DOG)
  @Provides
  String provideDog(){
    return "Bow-wow";
  }

  @IntoMap
  @NumberKey(Float.class)
  @Provides
  String provideFloatValue(){
    return "100f";
  }

  @IntoMap
  @NumberKey(Integer.class)
  @Provides
  String provideIntegerValue(){
    return "1";
  }
}
```

다음은 AnimalKey와 NumberKey를 사용하여 멀티 바인드를 하는 예제를 만들고 테스트한 결과다.

```java
@Test
public void testCustomMapKey(){
  MapKeyComponent component = DaggerMapKeyComponent.create();
  String cat = component.getStringsByAnimal().get(Animal.CAT);
  String dog = component.getStringsByAnimal().get(Animal.DOG);
  String number = component.getStringsByNumber().get(Float.class);

  System.out.println(cat);
  System.out.println(dog);
  System.out.println(number);
}
```

실행 결과

```
Meow
Bow-wow
100.0f
```

### 상속된 서브 컴포넌트의 멀티 바인딩

컴포넌트로부터 멀티 바인드된 Set 또는 Map을 서브 컴포넌트도 그대로 물려받을 수 있다. 다음 예제를 통해 서브 컴포넌트가 부모 컴포넌트로부터 멀티 바인드된 의존성을 그대로 물려받는지 확인한다.

```java
@Component(modules = ParentModule.class)
public interface ParentComponent{
  Set<String> string();
  ChildComponent.Builder childCompBuilder();
}
```

```java
@Module(subcomponents = ChildComponent.class)
public class ParentModule{
  @Provides
  @IntoSet
  String string1(){
    return "parent string 1";
  }

  @Provides
  @IntoSet
  String string2(){
    return "parent string2";
  }
}
```

```java
@SubComponent(modules = ChildModule.class)
public interface ChildComponent{
  Set<String> strings();

  @Subcomponent.Builder
  interface Builder{
    ChildComponent.build();
  }
}
```

```java
@Module
public class ChildModule{
  @Provides
  @IntoSet
  String string3(){
    return "child string 1";
  }

  @Provides
  @IntoSet
  String string4(){
    return "child string2";
  }
}
```

```java
@Test
public void testMultibindingWithSubcomponent(){
  ParentComponent parentComp = DaggerParentComponent.create();
  ChildComponent childComp = parentComp.childCompBuilder().build();

  System.out.println("List set in Parent");

  Iterator itr = parentComp.Strings().iterator();
  while(itr.hasNext()){
    System.out.println(itr.next());
  }

  System.out.println("List set in Child");

  itr = childComp.strings().iterator();
  while(itr.hasNext()){
    System.out.println(itr.next());
  }
}
```

실행 결과

```
List set in Parent
parent string 1
parent string 2
List set in Child
child string 2
child string 1
parent string 1
parent stirng 2
```

### 추상적인 멀티 바인딩 선언하기

컴포넌트는 여러 모듈을 사용할 수 있어 다른 모듈에 의해 멀티 바인드를 사용할 수도 있고 사용하지 않을 수도 있는 경우가 있다. 멀티 바인딩 사용 여부와 관계없이 멀티바인드를 컴포넌트 내에서 지원하는 @Multibinds 애노테이션을 사용한 멀티 바인딩을 선언할 수 있다.

@Multibinds 애노테이션은 모듈 내의 매개 변수를 갖지 않는 추상 메서드에 사용할 수 있으며, 이 메서드는 반환 타입의 Map 또는 Set 여야 한다. 다음 예제를 통해 모듈 내에서 멀티 바인딩을 어떻게 선언하는지 확인할 수 있다.

```java
@Module
public abstract class MultibindsModule{
  @Multibinds
  abstract Set<String> strings();
}
```

앞의 모듈을 컴포넌트에 추가하고 선언된 멀티 바인딩 Set를 컴포넌트의 메서드로 추가한다면 다음과 같다.

```java
@Component(modules = MultibindsModules.class)
public interface MultibindsComponent{
  Set<String> getStrings();
}
```

해당 컴포넌트를 생성해서 Set의 내용을 조회한 결과는 다음과 같다.

```java
@Test
public void testMultibinds(){
  MultibindsComponent component = DaggerMultibindsComponent.create();

  // 비어 있음
  for(String s : component.getStrings()){
    System.out.println(s);
  }
}
```

실행 결과

비어 있는 Set이므로 아무것도 출력되지 않는다. 외부로부터 멀티 바인딩된 객체가 컴포넌트의 의존성으로 추가된다면 Set를 조회했을 때 무언가 출력되는 것을 확인할 수 있다. 비어 있는 Set를 멀티 바인딩한 효과와 같아 다음과 같이 @Multibinds 애노테이션을 사용하지 않고 @ElementsIntoSet 만을 사용해서 멀티 바인딩을 선언할 수도 있다.

```java
@Module
public abstract class MultibindsModules{
  @Provides
  @ElementsIntoSet
  static Set<String> emptyStrings(){
    return Collections.emptySet();
  }
}
```
