[ { "title": "Android Fragment", "url": "/posts/Android_Fragment/", "categories": "Android, Basic", "tags": "Android, Fragment", "date": "2021-11-14 15:54:00 +0000", "snippet": "Fragment 란? Fragment는 앱 UI의 재사용 가능한 부분을 나타낸다. 프래그먼트는 자체 레이아웃을 정의 및 관리하고 자체 수명 주기를 보유하며 자체 입력 이벤트를 처리할 수 있다. 프레그먼트는 독립적으로 존재할 수 없고 Activity나 다른 프래그먼트에서 호스팅되어야 한다. 프르그먼트의 뷰 계층 구조는 호스트 뷰 계층 구조의 일부가 되거나 여기에 연결된다. 모듈성 프래그먼트는 UI를 개별 청크로 분할할 수 있도록 하여 Acitivty의 UI에 모듈성 재사용성을 도입한다..." }, { "title": "Android Activity", "url": "/posts/Android_Activity/", "categories": "Android, Basic", "tags": "Android, Activity", "date": "2021-11-09 16:00:00 +0000", "snippet": "Activity 란? An activity is the entry point for interacting with the user. It represents a single screen with a user interface 사용자와 상호작용하는 위한 진입점이다. 사용자 인터페이스를 포함한 화면 하나를 나타낸다. The Activity class is a crucial component of an Android app, and the way activities are launched and p..." }, { "title": "Compose - 상태 및 Jetpack Compose", "url": "/posts/%EC%83%81%ED%83%9C_%EB%B0%8F_Jetpack_Compose/", "categories": "Android, Compose", "tags": "Android, Compose", "date": "2021-11-08 15:31:00 +0000", "snippet": " https://developer.android.com/jetpack/compose 공식 문서를 보고 정리한 글입니다.상태 및 Jetpack Compose상태 및 컴포지션 Compose는 선언적이므로 Compose를 업데이트하는 유일한 방법은 새 인수로 동일한 컴포저블을 호출하는 것이다. 이러한 인수는 UI상태를 표현한다. 상태가 업데이트될 때마다 재구성이 실행된다. 따라서 TextField와 같은 항목은 명령형 XML기반 뷰에서 처럼 자동으로 업데이트가 되지 않으므로 새 상태에 따라 업데이트 되려면 새..." }, { "title": "Compose - Compose의 이해", "url": "/posts/Compose_Compose%EC%9D%98_%EC%9D%B4%ED%95%B4/", "categories": "Android, Compose", "tags": "Android, Compose", "date": "2021-11-05 16:14:00 +0000", "snippet": " https://developer.android.com/jetpack/compose 공식 문서를 보고 정리한 글입니다.Compose 이해 Jetpack Compose는 Android를 위한 현대적인 선언형 UI 도구 키트이다. Compose는 프런트엔드 뷰를 명령형으로 변형하지 않고도 앱 UI를 렌더링할 수 있게 하는 선형형 API를 제공하여 앱 UI를 더 쉽게 작성하고 유지관리할 수 있도록 지원한다.선언형 프로그래밍 패러다임기존 방식 기존 Android 뷰 계층 구조는 UI 위젯의 트리 형태 사용자 상호작용 등의 이..." }, { "title": "Maven Central에 Android Library 배포하기", "url": "/posts/Maven_Central%EC%97%90_Android_Library_%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/", "categories": "Android, Library", "tags": "Android, MavenCentral, Maven, Library", "date": "2021-10-17 13:10:00 +0000", "snippet": "Sonatype Jira Account 생성https://issues.sonatype.org/Sonatype Jira에서 새로운 이슈 생성참고 이슈 신규 프로젝트 생성 제목 입력 ex) Create repository for io.github.yunjaena:slackwebhook Group id ex) io.github.yunjaena Project URL ex) https://github.com/yunjaena/SlackWebhookAndroid ..." }, { "title": "Slack Webhook from Android", "url": "/posts/Slack_webhook_from_Android/", "categories": "Android, Advance", "tags": "Android, Slack", "date": "2021-06-14 17:15:00 +0000", "snippet": "Android 앱에서 크리티컬한 이슈가 발생하였을때(ex) 인앱 결제 실패, SNS 로그인 실패 등..) 빠른 대응을 하고 싶은 경우가 생겨서 슬랙으로 메시지를 보내는 방법을 생각하게 되었다.사용 라이브러리 WorkManager : 앱이 종료되거나 기기가 시작될때 또는 네트워크가 연결되어있을때 메시지를 보내기 위해 사용 Retrofit : REST 기반의 웹 서비스를 통해 JSON 구조의 데이터를 쉽게 가져오고 업로드 가능하게 도와주는 라이브러리 설정 및 구현 과정Slack 설정 Slack 에서 Web..." }, { "title": "RxJava - 테스트(2)", "url": "/posts/RxJava_RxJava%EC%97%90%EC%84%9C%EC%9D%98_%ED%85%8C%EC%8A%A4%ED%8A%B8(2)/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2021-01-12 13:58:00 +0000", "snippet": "테스트를 위한 TestSubscriber / TestObserver 테스트 용도로 사용되는 소비자 클래스이다. assertXXX 함수를 이용해 통지된 데이터를 검증할 수 있다. awaitxxxxx 함수를 이용해서 지정된 시간 동안 대기하거나 완료 또는 에러 이벤트가 발생할 때까지 대기할 수 있다. 완료, 에러, 구독 해지 등의 이벤트 발생 결과 값을 이용해서 데이터를 검증할 수 있다. assertEmpty 테스트 시점까지 통지받은 데이터가 없다면 테스트에 성공한다. ..." }, { "title": "RxJava - 테스트(1)", "url": "/posts/RxJava_RxJava%EC%97%90%EC%84%9C%EC%9D%98_%ED%85%8C%EC%8A%A4%ED%8A%B8(1)/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2021-01-01 07:10:00 +0000", "snippet": "테스트를 위한 blockingXXX 함수 비동기 처리 결과를 테스트하려면 현재 쓰레드에서 호출 대상 쓰레드의 실행 결과를 반환 받을때까지 대기할 수 있어야 한다. RxJava에서는 현재 쓰레드에서 호출 대상 쓰레드의 처리 결과를 받을 수 있는 blockingXXX 함수를 제고안다. Observable에서 통지되고 가공 처리된 결과 데이터를 현재 쓰레드에 반환하므로, 반환된 결과 값과 예상되는 기대값을 비교해서 단위 테스트를 수행할 수 있다. RxJava의 API를 사용하지 않은 Unit Te..." }, { "title": "RxJava - 디버깅", "url": "/posts/RxJava_%EB%94%94%EB%B2%84%EA%B9%85/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-29 13:20:00 +0000", "snippet": "RxJava의 디버깅 문제점과 대안 RxJava 프로그래밍은 데이터를 생성 및 통지하고 이를 구독하여 처리하는 과정이 하나의 문장으로 되어 있다. 즉, RxJava 프로그래밍은 선언적 프로그래밍 방식이기때문에 데이터의 상태 변화를 확인하기 위한 디버깅이 쉽지 않다. RxJava 프로그래밍은 여러 쓰레드가 동시에 실행되는 비동기 프로그래밍이기때문에 실행 시, 항상 같은 결과가 나온다는 보장을 할 수가 없다. 이러한 문제점을 해결하기 위해 RxJava에서는 doXXX로 시작하는 함수를..." }, { "title": "RxJava - 스케쥴러의 종류(2)", "url": "/posts/RxJava_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC%EC%9D%98_%EC%A2%85%EB%A5%98(2)/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-28 11:20:00 +0000", "snippet": "스케쥴러(Scheduler)의 종류(2) 스케쥴러 설명 Schedulers.trampoline() - 현재 실행되고 있는 쓰레드에 큐(Queue)를 생성하여 처리할 작업들을 큐에 넣고 순서대로 처리한다. =&amp;gt; FIFO(First In First Out) Schedulers.single() - 단일 쓰레드를 생성하여 처리 작업을 진핸한다.- 여러번 구독해도 공통으로 사용한다. Schedulers..." }, { "title": "RxJava - 스케쥴러란? + 스케쥴러의 종류(1)", "url": "/posts/RxJava_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC%EB%9E%80_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC%EC%9D%98_%EC%A2%85%EB%A5%98(1)/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-21 04:20:00 +0000", "snippet": "스케쥴러(Scheduler)란? RxJava에서의 스케쥴러는 RxJava 비동기 프로그래밍을 위한 쓰레드(Thread) 관리자이다. 즉, 스케쥴러를 이용해서 어떤 쓰레드에서 무엇을 처리할 지에 대해서 제어할 수 있다. 스케쥴러를 이용해서 데이터를 통지하는 쪽과 데이터를 처리하는 쪽 쓰레드를 별도로 지정해서 분리할 수 있다. RxJava의 스케쥴러를 통해 쓰레드를 위한 코드의 간결성 및 쓰레드 관리의 복잡함을 줄일 수 있다. RxJava에서 스케쥴러를 지정하기 위해서 subscribeOn(), observeOn() 유틸..." }, { "title": "RxJava - 물리적인 쓰레드와 논리적인 쓰레드의 이해", "url": "/posts/RxJava_%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9D%B8_%EC%93%B0%EB%A0%88%EB%93%9C%EC%99%80_%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9D%B8_%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98_%EC%9D%B4%ED%95%B4/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-20 06:20:00 +0000", "snippet": "물리적인 쓰레드와 논리적인 쓰레드의 이해 물리적인 쓰레드는 하드웨어와 관련이 있고, 논리적인 쓰레드는 소프트웨어와 관련이 있다. 물리적인 쓰레드를 이해하기 위해서는 CPU의 코어를 먼저 알아야 한다. 그럼 코어란? CPU의 명령어를 처리하는 반도체 유닛 코어의 갯수가 많으면 명령어를 병렬로(parallel) 더 많이 더 빠르게 처리할 수 있다. 물리적인 쓰레드는 물리적인 코어를 논리적으로 쪼갠 논리적 코어이다.논리적인 쓰레드란? 자바 프로그래밍에서 사용하는 그 쓰레드가 논리적인 쓰레..." }, { "title": "RxJava - Processor와 Subject", "url": "/posts/RxJava_Processor%EC%99%80_Subject/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-18 03:20:00 +0000", "snippet": "Projector와 Subject란? Processor는 Reactive Streams에서 정의한 Publisher 인터페이스와 Subscriber 인터페이스를 둘 다 상속한 확장 인터페이스이다.public interface Processor&amp;lt;T, R&amp;gt; extends Subscriber&amp;lt;T&amp;gt;, Publisher&amp;lt;R&amp;gt; {} 즉, Processor는 Publisher(생산자)의 기능과 Subscriber(소비자)의 기능을 모두 가지고 있다. Proce..." }, { "title": "RxJava - 데이터 집계 연산자", "url": "/posts/RxJava_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%A7%91%EA%B3%84_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-14 15:27:00 +0000", "snippet": "데이터 집계 연산자count Observable이 통지한 데이터의 총 개수를 통지한다. 총 개수만 통지하면 되므로 결과값은 Single로 반환한다. 데이터의 총 개수를 통지하는 시점은 완료 통지를 받은 시점이다./** * count를 이용하여 차량의 총 대수를 계산하는 예제 */public class ObservableCountExample01 { public static void main(String[] args) { Observable.fromIterable(SampleData.carList) ..." }, { "title": "RxJava - 조건과 불린 연산자", "url": "/posts/RxJava_%EC%A1%B0%EA%B1%B4%EA%B3%BC_%EB%B6%88%EB%A6%B0_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-14 10:30:00 +0000", "snippet": "조건과 불린 연산자all 통지되는 모든 데이터가 설정한 조건에 맞는지를 판단한다. 결과값을 한번만 통지하면 되기떄문에 true/false 값을 Single로 반환한다. 통지된 데이터가 조건에 맞지 않는다면 이후 데이터는 구독 헤지되어 통지 되지 않는다./** * all을 이용하여 통지된 모든 데이터가 파라미터로 입력된 조건과 일치하는지 판단하는 예제 */public class ObservableAllExample { public static void main(String[] args) { Observab..." }, { "title": "RxJava - 유틸리티 연산자", "url": "/posts/RxJava_%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-13 23:00:00 +0000", "snippet": "유틸리티 연산자delay 첫번째 유형 생산자가 데이터를 생성 및 통지를 하지만 설정한 시간만큼 소비자쪽으로의 데이터 전달을 지연시킨다./** * 통지된 데이터를 소비자 쪽에서 전달 받는 시간을 일정 시간동안 지연 시키는 예제 */public class ObservableDelayExample01 { public static void main(String[] args) { Logger.log(LogType.PRINT, &quot;# 실행 시작 시간: &quot; + TimeUtil.getCurrentTimeF..." }, { "title": "RxJava - 에러 처리 연산자", "url": "/posts/RxJava_%EC%97%90%EB%9F%AC_%EC%B2%98%EB%A6%AC_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-13 15:30:00 +0000", "snippet": "RxJava try catch로 에러 처리 불가능public class CanNotUserTryCatchExample { public static void main(String[] args) { try { Observable.just(2) .map(num -&amp;gt; num / 0) .subscribe(System.out::print); } catch (Exception e) { Log..." }, { "title": "RxJava - 데이터 결합 연산자", "url": "/posts/RxJava_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EA%B2%B0%ED%95%A9_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-13 07:30:00 +0000", "snippet": "데이터 결합 연산자merge 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Flowable/Observable로 통지한다. 통지 시점이 빠른 Observable의 데이터부터 순차적으로 통지되고 통지 시점이 같을 경우에는 merge() 함수의 파라미터로 먼저 지정된 Observable의 데이터부터 통지된다.   200ms 400ms 600ms 800ms 1000ms 1200ms 1400ms 1600ms 18..." }, { "title": "RxJava - 데이터 변환 연산자 (2)", "url": "/posts/RxJava_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B3%80%ED%99%98_%EC%97%B0%EC%82%B0%EC%9E%90(2)/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-13 01:30:00 +0000", "snippet": "데이터 변환 연산자groupBy 하나의 Observable을 여러개의 새로운 GroupedByObservable로 만든다. 원본 Observable의 데이터를 그룹별로 묶는다기보다는 각각의 데이터들이 그룹에 해당하는 Key를 가지게 된다. GroupedByObservable은 getKey()를 통해 구분된 그룹을 알 수 있게 해준다./** * Car 제조사 별로 그룹으로 묶어서 데이터를 통지하는 예제 */public class ObservableGroupByExample01 { public static void ma..." }, { "title": "RxJava - 데이터 변환 연산자 (1)", "url": "/posts/RxJava_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B3%80%ED%99%98_%EC%97%B0%EC%82%B0%EC%9E%90(1)md/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-12 13:10:00 +0000", "snippet": "데이터 변환 연산자map 원본 Observable에서 통지하는 데이터를 원하는 값으로 변환 후 통지한다. 변환 전, 후 데이터 타입은 달라도 상관없다. null을 반환하면 NullpointException이 발생하므로 null이 아닌 데이터 하나를 반드시 반환해야 한다./** * Observable이 통지한 항목에 함수를 적용하여 통지된 값을 변환시킨다. */public class ObservableMapExample01 { public static void main(String[] args) { Lis..." }, { "title": "RxJava - 데이터 필터링 연산자", "url": "/posts/RxJava_%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%95%84%ED%84%B0%EB%A7%81_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-12 12:10:00 +0000", "snippet": "데이터 필터링 연산자filter 전달 받은 데이터가 조건에 맞는지 확인한 후, 결과가 true인 데이터만 통지한다. filter 라는 단어의 사전적 의미가 무언가를 걸러낸다는 의미이다. 파라미터로 받는 Predicate 함수형 인터페이스에서 조건을 확인한다.public class ObservableFilterExample01 { public static void main(String[] args) { Observable.fromIterable(SampleData.carList) ..." }, { "title": "RxJava - 연산자 개요 및 생성 연산자", "url": "/posts/RxJava_%EC%97%B0%EC%82%B0%EC%9E%90_%EA%B0%9C%EC%9A%94_%EB%B0%8F_%EC%83%9D%EC%84%B1_%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-11 18:10:00 +0000", "snippet": "RxJava의 연산자(Operator)란? RxJava에서의 연산자는 메서드(함수)다. 연산자를 이용하여 데이터를 생성하고 통지하는 Flowable이나 Observable 등의 생산자를 생성할 수 있다. Flowable이나 Observable에서 통지한 데이터를 다양한 연산자를 사용하여 가공 처리하여 결과값을 만들어 낸다. 연산자의 특성에 따라 카테고리로 분류된다. Flowable/Observable 생성 연산자 통지된 데이터를 필터링 해주는 연산자 통지된 데이터를 변환 해주는 연산자 ..." }, { "title": "RxJava - 함수형 메서드 레퍼런스", "url": "/posts/RxJava_%EB%A9%94%EC%84%9C%EB%93%9C_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-11 15:10:00 +0000", "snippet": "메서드 레퍼런스란? 우리말로 번역하면 메서드 참조라는 의미이다. 람다 표현식 body(몸체) 부분에 기술되는 메서드를 이용해서 표현되며, 메서드의 이름만 전달한다. 구분자(::)를 붙이는 방식으로 메서드 레퍼런스를 표현한다. 메서드 레퍼런스를 사용하면 람다 표현식이 더욱 간결해진다. 메서드 레퍼런스의 표현 예 (Car car) -&amp;gt; car.getCarName() = Car::getCarName 메서드 레퍼런스의 유형ClassName::static method (String s) ..." }, { "title": "RxJava - 함수형 인터페이스와 람다", "url": "/posts/RxJava_%ED%95%A8%EC%88%98%ED%98%95_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-11 05:00:00 +0000", "snippet": "함수형 인터페이스란? 함수형 인터페이스는 말 그대로 Java의 interface 이다. 함수형 인터페이스는 단 하나의 추상 메서드만 가지고 있는 인터페이스이다.(예외 : 디폴트 메서드는 포함할 수 있음) 함수형 인터페이스의 메서드를 람다 표현식으로 작성해서 다른 메서드의 파라미터로 전달할 수 있다. 즉, 람다 표현식 전체를 해당 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급한다. Java 8에서 새롭게 추가된 함수형 인터페이스 외에 기존에 작성되어 있는 하나의 추상 메서드만 가지고 있는 Java의 interfac..." }, { "title": "RxJava - Single vs Maybe vs Completable", "url": "/posts/RxJava_Single_vs_Maybe_vs_Completable/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-11 01:00:00 +0000", "snippet": "Single 데이터를 1건만 통지하거나 에러를 통지한다. 데이터 통지 자체가 완료를 의미하기 때문에 완료 통지는 하지 않는다. 데이터를 1건만 통지하므로 데이터 개수를 요청할 필요가 없다. onNext(), onComplete()가 없으며 이 둘을 합한 onSuccess()를 제공한다. Single의 대표적인 소비자는 SingleObserver이다. 클라이언트의 요청에 대응하는 서버의 응답이 Single을 사용하기 좋은 대표적인 예다./** * Single 클래스를 사용하여 현재 날짜와 시각을 통지하는 예제 */pu..." }, { "title": "RxJava - Flowable과 Observable", "url": "/posts/RxJava_Flowable%EA%B3%BC_Observable/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-10 10:00:00 +0000", "snippet": "Flowable과 Observable의 비교 Flowable Observable Reactive Streams 인터페이스를 구현함 Reactive Streams 인터페이스를 구현하지 않음 Subscriber에서 데이터를 처리한다. Observer에서 데이터를 처리한다. 데이터 개수를 제어하는 배압 기능이 있음 데이터 개수를 제어하는 배압 기능이 없음 Subscription으..." }, { "title": "RxJava - Reative Streams란?", "url": "/posts/RxJava_Reatvie_Stream%EB%9E%80/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-10 09:00:00 +0000", "snippet": "Reactive Streams란? 리액티브 프로그래밍 라이브러리의 표준 사양이다. =&amp;gt; 참고링크 리액티브 프로그래밍에 대한 인터페이스만 제공한다. RxJava는 이 Reactive Streams의 인터페이스들을 구현한 구현체이다. Reactive Streams는 Publisher, Subscriber, Subscription, Processor 라는 4개의 인터페이스를 제공한다. Publisher(생산자) : 데이터를 생성하고 통지한다. Subscriber(소비자) : 통지된 데이터..." }, { "title": "RxJava - 프로젝트 환경 구축 및 Hello RxJava", "url": "/posts/RxJava_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8_%ED%99%98%EA%B2%BD_%EA%B5%AC%EC%B6%95_%EB%B0%8F_Hello_RxJava/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-09 11:00:00 +0000", "snippet": "RxJava 프로젝트 환경 구축 순서 JDK 설치 (1.8 이상의 JDK가 설치 되어 있다고 가정함) IDE 다운로드 및 설치 IDE에 프로젝트 생 RxJava를 위한 의존 라이브러리 설치 정상적으로 동작하는지 Hello RxJava 코드 작성 및 실행IDE 다운로드 및 설치 JetBrain의 IntelliJ IDE 다운로드 및 설치 : https://www.jetbrains.com/ko-kr/idea/IDE 실행 Create New Project Gradle 선택 프로젝트 이름 설정RxJava를 위한 의존 ..." }, { "title": "RxJava - 마블 다이어그램 소개", "url": "/posts/RxJava_%EB%A7%88%EB%B8%94_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8_%EC%86%8C%EA%B0%9C/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-08 11:00:00 +0000", "snippet": "마블 다이어그램이란?리액티브 프로그래밍을 통해 발생하는 비동기적인 데이터의 흐름을 시간의 흐름에 따라 시각적으로 표시한 다이어그램마블 다이어그램을 알아야하는 이유 문장으로 적혀 있는 리액티브 연산자(Operators)의 기능을 이해하기 어려움 리액티브 연산자의 기능이 시각화 되어 있어서 이해하기 쉬움 리액티브 프로그래밍의 핵심인 연산자(Operators)를 사용하기 위한 핵심 도구마블 다이어그램 보는 법 이 글은 inflearn에 있는 Kevin의 알기 쉬운 RxJava 1부를 공부하고 작성한 글입니다. 강의영상 링크" }, { "title": "RxJava - 리엑티브(Reative) 프로그래밍이란", "url": "/posts/RxJava_%EB%A6%AC%EC%97%91%ED%8B%B0%EB%B8%8C(Reative)_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80/", "categories": "Android, RxJava", "tags": "Android, RxJava", "date": "2020-12-07 06:00:00 +0000", "snippet": "리액티브 프로그래밍(Reactive Programming) 이란?변화의 전파와 데이터 흐름과 관련된 선언적 프로그래밍 패러다임이다. 변화의 전파와 데이터 흐름 : 데이터가 변경 될 때 마다 이벤트를 발생시켜서 데이터를 계속적으로 전달한다. 선언적 프로그래밍 : 실행할 동작을 구체적으로 명시하는 명령형 프로그램이과 달리 선언형 프로그래밍은 단순히 목표를 선언한다.리액티브의 개념이 적용된 예 Push 방식 : 데이터의 변화가 발생했을 떄 변경이 발생한 곳에서 데이터를 보내주는 방식 RTC(Real Time C..." }, { "title": "Android Database - Room", "url": "/posts/Andorid_Database_Room/", "categories": "Android, Database", "tags": "Android, Android Database", "date": "2020-11-02 06:00:00 +0000", "snippet": "Android Database RoomRoom 은 SQLite에 대한 추상화 레이어를 제공하여 원할한 데이터베이스 엑세스를 지원하는 동시에 SQLite를 완벽히 활용한다. 다양한 Annotation을 통해 컴파일시 코드들을 자동으로 만들어주며 LiveData, RxJava와 같은 Observation 형태를 지원 또한 MVP, MVVM 등과 같은 아키텍쳐 패턴에서 활용하기 쉽다.공식 문서는 해당 링크를 참조하면 된다. https://developer.android.com/training/data-storage/roomBefo..." }, { "title": "Android Database - Realm", "url": "/posts/Andorid_Database_Realm/", "categories": "Android, Database", "tags": "Android, Android Database", "date": "2020-11-02 06:00:00 +0000", "snippet": "Android Realm DatabaseRealm(렘)은 오픈소스 데이터베이스 관리시스템(DBMS) 이며 모바일 환경을 주요 타깃으로 삼은 데이터베이스이다.Realm은 매우 작은 리소스를 사용하고 사용하기 쉽고 더 빠르게 데이터와 상호 작용 가능하다.NoSQL 데이터베이스를 지향하며 rawSQL을 사용할 수 없어 Realm API를 통해서 실행된다.한국어 공식 문서도 제공하지만 kotlin 인 경우 현제 영어 문서만 제공하고 있다.Java : https://realm.io/docs/java/latest/Kotlin : http..." }, { "title": "Android Database - SQLite", "url": "/posts/Andorid_Database_SQLite/", "categories": "Android, Database", "tags": "Android, Android Database", "date": "2020-10-19 07:38:00 +0000", "snippet": "Android SQLiteAndroid 에서 database를 사용할 때 필요한 API는 android.database.sqlite 패키지로 제공한다. 하지만 2017년 Google I/O 에서 Android Architecture Components(AAC)를 발표하면서 Android Developer 사이트에는 SQLite를 직접 사용하는것은 low level API 이며 구현시 오류발생의 가능성이 높아 안전하게 사용하기 위해 AAC 의 ROOM을 사용하는 것을 추천하고 있다. Room은 SQLite를 추상화 하여 쉽게 d..." }, { "title": "메인 스레드와 Handler - (3)", "url": "/posts/%EB%A9%94%EC%9D%B8_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_Handler(3)/", "categories": "Android, Advance", "tags": "Android, Thread", "date": "2020-01-22 07:38:00 +0000", "snippet": "Handler 동작 Handler는 Message를 MessageQueue에 보내는 것과 Message를 처리하는 기능을 함께 제공한다. post(), postAtTime(), postDelayed() 메서드를 통해서 Runnable 객체도 전달되는데, Runnable도 내부적으로 Message에 포함되는 값이다. sendEmptyMessage(), sendEmptyMessageDelaye(), sendEmptyMessageAtTime() 메서드는 Message의 what 값만을 전달한다. Delayed()로 끝나는 메..." }, { "title": "메인 스레드와 Handler - (2)", "url": "/posts/%EB%A9%94%EC%9D%B8_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_Handler(2)/", "categories": "Android, Advance", "tags": "Android, Thread", "date": "2020-01-21 06:51:00 +0000", "snippet": "Handler class Handler는 Message를 MessageQueue에 넣는 기능과 MessageQueue에서 꺼내 처리하는 기능을 함께 제공한다.Handler 생성자 Handler에는 기본 생성자 외에도 Handler.Callback 이 전달되는 생성자도 있고, Looper가 전달되는 생성자도 있다. Handler() Handler(Handler.Callback callback) Handler(Looper looper) Handler(Looper looper, Hand..." }, { "title": "메인 스레드와 Handler - (1)", "url": "/posts/%EB%A9%94%EC%9D%B8_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_Handler(1)/", "categories": "Android, Advance", "tags": "Android, Thread", "date": "2020-01-17 02:59:00 +0000", "snippet": "UI 처리를 위한 메인 스레드 어플리케이션은 성능을 위해 멀티 스레드를 많이 활용하지만 , UI를 업데이트하는 데는 단일 스레드 모델이 적용된다. 멀티 스레드로 UI를 업데이트를 하게 될 경우 교착 상태, 경합 상태등 여러 문제가 생길 수 있어 UI를 업데이트하는 것은 메인 스레드에서만 허용한다. 컴포넌트 (액티비티, 서비스, 브로드캐스트 리시버, Application)의 생명주기 메서드와 그 안의 메서드 호출은 기본적으로 메인 스레드에서 실행된다.자바 애플리케이션에서 메인 스레드 일반적인 자바 애플리케이션에서 main(..." } ]
